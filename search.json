[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Data Management",
    "section": "",
    "text": "Course overview\nThis course (and this accompanying website) are designed to provide you with a practical introduction to data management. It is a hands-on course in which you will get comfortable working with data, with a focus on data structures and database design. After completing this course, you hopefully will have a better understanding of how data infrastructures support the organizations, websites and applications that we use everyday, and feel confident in your ability to work with data and design effective databases that meet the needs of your users."
  },
  {
    "objectID": "index.html#schedule",
    "href": "index.html#schedule",
    "title": "Data Management",
    "section": "Schedule",
    "text": "Schedule\nThe class will be on Thursdays from 2:35 pm to 5:25 pm in the Sir James Dunn building, room 301A.\nAdditional lab time and support will be available Tuesday afternoons, from 1:00 pm to 4:00 pm, at Rowe 4025.\nIf you wish to book a meeting with me on Teams or outside of office hours, please use this link.\n\n\n\n\n \n  \n    Date of Class \n    Topics \n  \n \n\n  \n    Week 1 (Jan 11) \n    Course overview \n  \n  \n    Week 2 (Jan 18) \n    Thinking about data \n  \n  \n    Week 3 (Jan 25) \n    Relational model \n  \n  \n    Week 4 (Feb 1) \n    Relational model \n  \n  \n    Week 5 (Feb 8) \n    Relational model \n  \n  \n    Week 6 (Feb 15) \n    Relational database management systems \n  \n  \n    Reading week (Feb 22) \n     \n  \n  \n    Week 7 (Mar 1) \n    Structured Query Language (SQL) \n  \n  \n    Week 8 (Mar 8) \n    Structured Query Language (SQL) \n  \n  \n    Week 9 (Mar 15) \n    Free lab time \n  \n  \n    Week 10 (Mar 22) \n    Document databases \n  \n  \n    Week 11 (Mar 29) \n    Graph databases \n  \n  \n    Week 12 (Apr 5) \n    Course wrap-up"
  },
  {
    "objectID": "index.html#assignments",
    "href": "index.html#assignments",
    "title": "Data Management",
    "section": "Assignments",
    "text": "Assignments\n\n\n\n\n \n  \n    Component \n    Details \n    Due date \n    Value \n  \n \n\n  \n    Lab 1 \n    Excel \n    2022-01-31 \n    5% \n  \n  \n    oup project part 1 \n    Mission statement and objectives \n    2022-02-03 \n    5% \n  \n  \n    Lab 2 \n    Entity-relationsip diagram \n    2022-02-21 \n    10% \n  \n  \n    Group project part 2 \n    Database design \n    2022-02-24 \n    25% \n  \n  \n    Lab 3 \n    SQL \n    2022-03-07 \n    5% \n  \n  \n    Group project part 3 \n    SQL and database views \n    2021-03-10 \n    10% \n  \n  \n    Lab 4 \n    JSON \n    2022-03-21 \n    5% \n  \n  \n    Participation \n    Team assessment \n    2022-03-24 \n    10% \n  \n  \n    Assignment 2 \n    Build your own ontology \n    2022-04-14 \n    25%"
  },
  {
    "objectID": "index.html#official-syllabus",
    "href": "index.html#official-syllabus",
    "title": "Data Management",
    "section": "Official syllabus",
    "text": "Official syllabus\n\n\n\nThis browser does not support PDFs. Please download the PDF to view it: <a href=“files/syllabus/INFO6540_Syllabus.pdf”>Download PDF</a>."
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "This is a book created from markdown and executable code.\nSee Knuth (1984) for additional discussion of literate programming.\n\n1 + 1\n\n[1] 2\n\n\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "2  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever.\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Knuth, Donald E. 1984. “Literate Programming.” Comput.\nJ. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "introduction.html#learning-objectives",
    "href": "introduction.html#learning-objectives",
    "title": "1  Thinking about data",
    "section": "1.1 Learning objectives",
    "text": "1.1 Learning objectives\n\nUnderstanding the concepts of data, dataset, database, data management, and data management systems.\nUnderstanding the difference between unstructured, semi-structured, and structured data."
  },
  {
    "objectID": "introduction.html#what-is-data",
    "href": "introduction.html#what-is-data",
    "title": "1  Thinking about data",
    "section": "1.2 What is data?",
    "text": "1.2 What is data?\nThe Merriam-Webster online dictionary provides three definitions of the word data:\n\nfactual information (such as measurements or statistics) used as a basis for reasoning, discussion, or calculation.\n\n\ninformation in digital form that can be transmitted or processed\n\n\ninformation output by a sensing device or organ that includes both useful and irrelevant or redundant information and must be processed to be meaningful\n\n— Merriam-Webster dictionary\n\n\nTogether, these definitions offer us a set of key elements from which we can build a broad understanding of the concept of data. The first key term is factual information or fact suggesting that data is objective and, like the rest of the definition shows, is used for a given purpose, such as discussing reasoning or decision-making.\nThe second definition is related to using the word data in a computational or communicational sense, where data is the “thing” that is being stored, transmitted, received, processed, etc.\nWhile the first definition suggests that humans and machines use data for processes such as decisions and calculations, the third definition highlights that data does not only exist in nature but can also be created by humans and machines, either purposefully or not.\nWhile we often think of data as things found in spreadsheets and stored in computers or filing cabinets, data is much more than that. Data is everywhere around us all the time in the form of energy and sound or light waves, for instance. Our sensory organs are data captors that pick up data from our environment. Our brains process, structure, and possibly store the data so we can consciously or unconsciously use it now or later as a basis for decisions and actions. That said, in this course, we will not concern ourselves with this kind of data and process. Instead, we will focus on digitally recorded data, the kind that we can store in a computer."
  },
  {
    "objectID": "introduction.html#datasets",
    "href": "introduction.html#datasets",
    "title": "1  Thinking about data",
    "section": "1.3 Datasets",
    "text": "1.3 Datasets\nWe often encounter the term “dataset” on the web or in our workplaces, and I think it is worth writing a few lines to relate the terms to the other terms we will use in this course. The terms data and dataset will often be used interchangeably since dataset literally means a set of data, and data is the plural of datum. One difference, in principle, is that datasets are usually assembled for a given purpose. In research, for instance, a dataset will be the exact collection of data collected for the analysis. In supervised machine learning, we distinguish between training and testing datasets. When a professor sends you an excel file with data to work with for an assignment, that’s a dataset. You find datasets when you browse websites like kaggle.com, zenodo.org, or dataverse.org. Datasets are also static, whereas databases can be dynamic."
  },
  {
    "objectID": "introduction.html#databases",
    "href": "introduction.html#databases",
    "title": "1  Thinking about data",
    "section": "1.4 Databases",
    "text": "1.4 Databases\nWhat is a database? According to the Merriam-Webster dictionary, a database is “a usually large collection of data organized especially for rapid search and retrieval (as by a computer)”. The keyword here is organized, highlighting that databases are both products and tools for data management.\nDatabases are usually created and managed for some purposes. These purposes may be specific (e.g. keeping track of a store’s inventory) or broad (tracking socioeconomic trends). Depending on their purposes, databases can vary in size and complexity. Any organized data collection could be considered a database, even if it is as basic as an Excel spreadsheet with the names and addresses of your friends or your to-do list.\nA database can contain or be used to create multiple datasets, but a dataset would typically not contain multiple databases. Of course, this does not mean that datasets are always drawn from databases. For example, datasets can be created by surveying or interviewing people or recording observations of natural phenomena.\nNote, however, that those differences are not hard truths, as some datasets may serve a greater variety of users and purposes than some databases."
  },
  {
    "objectID": "introduction.html#database-management-systems-dbms",
    "href": "introduction.html#database-management-systems-dbms",
    "title": "1  Thinking about data",
    "section": "1.5 Database management systems (DBMS)",
    "text": "1.5 Database management systems (DBMS)\nA Database Management System (DBMS) is software that supports the development, maintenance, security, and use of databases. You will often come across the DBMS acronym with different suffixes attached to it, such as RDBMS (Relational DBMS), OODBMS (Object-Oriented DBMS), or ORDBMS (Object-Relational DBMS). Note that all these DBMS generally offer the same basic features. The main difference is that they work with different data types and structures. In this course you will use one RDBMS called pgAdmin to put implement your database design on a live server. You will also be introduced to the two popular DBMSs: MongoDB and Neo4j for document databases and graph databases, respectively.\nMost DBMS are pretty easy to get started with, and some will provide standard templates for tables and data structures. But as Hernandez (2013) writes in the introduction of their popular database design book, diving in without proper preparation and relying too much on templates is an easy way to end up with a design that is inefficient or does not work. A bad database design will lead to data problems such as missing, incorrect, or mismatched data. It will fail to play its role in supporting the organization or serving the users."
  },
  {
    "objectID": "introduction.html#data-management",
    "href": "introduction.html#data-management",
    "title": "1  Thinking about data",
    "section": "1.6 Data management",
    "text": "1.6 Data management\nSo far in this chapter, we explored the concepts of data and its different levels of structure, datasets, databases and data management systems. Aside from related to data, what do all these concepts have in common? They are what data managers work with. Data managers unlock the potential of data for a given purpose, individual, group or organization, by developing and implementing data strategies and processes such as data retrieval, processing, cleaning, storage and analysis.\nThe value of data depends on the purpose it serves. Thus, good data management requires a good understanding of both the data and the needs of its users so that optimal data strategies can be developed and implemented. In this course, you will get familiar with several tools to manage data and data-related processes and design a database that addresses the needs of an organization or group."
  },
  {
    "objectID": "introduction.html#from-unstructured-to-structured-data",
    "href": "introduction.html#from-unstructured-to-structured-data",
    "title": "1  Thinking about data",
    "section": "1.7 From unstructured to structured data",
    "text": "1.7 From unstructured to structured data\nData can take many forms that we can situate along a continuum with unstructured data at one extreme, structured data at the other, and semi-structured data in between. Let us consider a simple example to better grasp the difference between structured and unstructured data and, at the same time, to get a sense of the process of structuring data so that it can be more effectively strored and analyzed.\nHere is a brilliant piece of writing:\n\nA data story\nPhilippe Mongeon\nChapter 1\nOnce upon a time, a random internet user created a short text and abandoned it in a sea of unstructured data.\nChapter 2\nAn algorithm passed by and decided to add XML tags to the text.\nChapter 3\nA data manager stumbled upon the data and thought it would be relevant for the database users. So they decided to add it to their relational database.\nThe end.\n\nThat’s unstructured data (not entirely, the line breaks are a very basic structure). We humans who have read a book before can see the structure, but for a computer, this is just text. So now, let us give this text a little bit more structure by applying XML tags.\n\n<book>\n<title>A data story</title>\n<author>Philippe Mongeon</author>\n<h1>Chapter 1</h1>\n<p>Once upon a time a short text was created by a random internet user and abandoned in a sea of unstructured data.</p>\n<h1>Chapter 2</h1>\n<p>An algorithm passed by and decided to add xml tags to the text.</p>\n<h1>Chapter 3</h1>\n<p>A data manager stumbled upon the data, thought it would be relevant for the database users, and so she decided to add it to include it in her relational database.</p>\n<p>The end.</p>\n</book>\n\nThe XML tags already help us (and the computer) identify different text components, such as the title, the author, headers and paragraphs. XML documents are a typical example of semi-structured data.\nAnother frequently used semi-structured format is JSON, which in this case would look like this:\n\n{\n  \"title\": \"A data story\",\n  \"author\": \"Philippe Mongeon\",\n  \"Chapter 1\": \"Once upon a time a short text was created by a random internet user and abandoned in a sea of unstructured data.\",\n  \"Chapter 2\": \"An algorithm passed by and decided to add xml tags to the text.\",\n  \"Chapter 3\": \"A data manager stumbled upon the data, thought it would be relevant for the database users, and so she decided to add it to her relational database. The end.\"\n}\n\nNotice how I included the Chapter number in the tags here in this example? That was an arbitrary choice, and I could have chosen another structure for my file, such as this one:\n\n{\n  \"title\": \"A data story\",\n  \"author\": \"Philippe Mongeon\",\n  \"Chapters\": [\n      {\n        \"title\": \"Chapter 1\",\n        \"content\": \"Once upon a time a short text was created by a random internet user and abandoned in a sea of unstructured data.\"\n      }\n      {\n        \"title\": \"Chapter 2\",\n        \"content\": \"An algorithm passed by and decided to add xml tags to the text.\"\n      }\n      {\n        \"title\": \"Chapter 3\",\n        \"content\": \"A data manager stumbled upon the data, thought it would be relevant for the database users, and so she decided to add it to her relational database. The end.\"\n      }\n  ]\n}\n\nThis structure (or semi-structure) is just as good as the previous one. That flexibility is one of the reasons why semi-structured data formats and databases are growing in popularity. Because the data structure is included directly in the document, the users do not need to follow a predefined structure and use predefined tags to store their data in the database. This means that, theoretically, every record could have a different structure, which would be fine, but most likely not optimal. We will explore this type of structure and a popular DBMSs that uses it (MongoDB) later in the course.\nStructured data and databases are typically tabular (like an Excel spreadsheet). Each row is a record or entry, and each column is a field, feature, variable, etc. The structure is part of the database design (and not each database entry, as in the semi-structured format), and so every new record has to follow that same format. For example, here is the same work of art in a structured format.\n\n\n\n\nExample of structured data\n \n  \n    Title \n    Author \n    Section \n    Content \n  \n \n\n  \n    A data story \n    Philippe Mongeon \n    Chapter 1 \n    Once upon a time a data was created by a random internet user and abandoned in a see of unstructured data. \n  \n  \n    A data story \n    Philippe Mongeon \n    Chapter 2 \n    An algorithm passed by and decided to add xml tags to the text. \n  \n  \n    A data story \n    Philippe Mongeon \n    Chapter 3 \n    A data manager stumbled upon the data, thought it would be relevant for the database users, and so she decided to add it to include it in her relational database. The end. \n  \n\n\n\n\n\nHere, the structure is determined by the columns I chose for my table (title, author, section, and content). But, again, this was an arbitrary choice, and I could have chosen a completely different structure (although the realm of possibilities is somewhat limited by the data and by common sense). The point is that there is rarely an absolute best way of structuring data, and the best structure is the one that best suits the needs of the users. Sometimes the same data may be duplicated and structured differently to suit different users and uses.\nPerhaps you noticed that the title and author information is repeated in this last example, which is not a great database design. This course will teach you how to avoid such redundancies and design sound and efficient relational databases. We will talk about the relational model later in the course, but for now, note that relational databases are types of databases that follow a set of rules and principles that make them best suited for structured data."
  },
  {
    "objectID": "introduction.html#practice",
    "href": "introduction.html#practice",
    "title": "1  Thinking about data",
    "section": "1.8 Practice",
    "text": "1.8 Practice\nOver the next few weeks of the course, you will design a relational database, store data into it, and write SQL queries to retrieve data. But since this course is intended to be accessible to students with little to no experience working with data, this week is dedicated to developing or polishing your Microsoft Excel skills.\nWhile Excel has some data management capabilities, that’s not what it is designed and most commonly used for. You can still think of it as a very rudimentary form of DBMS. However, Excel is a flexible tool that you can use to quickly explore, manipulate and structure data before creating those structures in an actual DBMS. Excel will also always be relevant in your data management workflow because it remains one of the most accessible ways to work with data for downstream processes (before data gets stored in a DMBS) and upstream processes (after the data is retrieved from the DBMS).\n\n1.8.0.1 Formatting exercise\n\nDownload the Easy_Excel.xlsx file (provided by Julie Marcoux, a data librarian at the Killam Library)\nFollow the instructions in the instructions sheet.\nThe exercise sheet contains the data to format.\nAt the end of the exercise, your table should look similar to the one found in the Results sheet.\nThe Useful functions sheet contains tips on using some Excel formatting functions.\n\n\n\n1.8.0.2 Analyzing exercise\n\nWatch the demo on pivot tables in Excel below.\nCreate a pivot table to explore the data in the _The exercise sheet of the Easy_Excel.xlsx used for the first exercise.\nExplore ways of structuring your pivot table and combining and filtering columns.\nWhich publisher has the most books in the dataset?\nOn average, are cloth-bound books more or less expensive than paper-bound books?\n\n\n\n\n\n\n\nHernandez, Michael J. 2013. Database Design for Mere Mortals: A Hands-on Guide to Relational Database Design. Third edition. Upper Saddle River, NJ: Addison-Wesley."
  },
  {
    "objectID": "relational_databases_part1.html#learning-objectives",
    "href": "relational_databases_part1.html#learning-objectives",
    "title": "2  Relational databases (Pt. 1)",
    "section": "2.1 Learning objectives",
    "text": "2.1 Learning objectives\nConcepts\n\nMission and objectives statements\nRelational databases\nSubjects and attributes\nDatabase rules\n\nPractical skills\n\nWriting a mission and objectives statement for your database (team assignment #1) \nCreating database tables and fields (team assignment #2) \nDocumenting databases (team assignment #2)"
  },
  {
    "objectID": "relational_databases_part1.html#what-is-a-relational-database",
    "href": "relational_databases_part1.html#what-is-a-relational-database",
    "title": "2  Relational databases (Pt. 1)",
    "section": "2.2 What is a relational database?",
    "text": "2.2 What is a relational database?\nRelational databases store relations that are represented as tables. Each column of a table is an attribute (also called field, column, variable or feature). I will call fields from now on), and tuples (or records) are a set of attributes. For example, consider the table below, which is a set of relations representing students. Each record is a unique student defined by four attributes: their student ID, first name, last name, and program. The subject represented in this table are the students, and the same set of limited features represents all the students. No student can exist in this database with different features than the others. A relational database is a collection of tables linked to one another, each representing a different subject (courses, buildings, animals, concerts, orders, conversations, families, foods, games, or anything that we wish to capture in the database), and each with their own set of fields, and records.\n\nThe figure below shows how tables are linked to one another in the relational model.\n\nIn the next few weeks, you will learn how to design your own relational database, so let’s get started."
  },
  {
    "objectID": "relational_databases_part1.html#mission-and-objectives",
    "href": "relational_databases_part1.html#mission-and-objectives",
    "title": "2  Relational databases (Pt. 1)",
    "section": "2.3 Mission and objectives",
    "text": "2.3 Mission and objectives\nAs I mentioned in the opening chapter of this book, databases are created for a specific purpose, and that purpose should be clearly defined before you start creating tables and fields and their relationships. This is the first step of the database design process that Hernandez (2013) proposes in his book, so let us start there are well.\n\n2.3.1 Database mission statement\nThe database mission statement is a short text written in general and accessible language that states the specific purpose of your database. It is important to note that it is not the same as the organization’s mission statement for which the database will be designed. Instead, this statement refers specifically to the database and what the database will do for the organization. To keep that in mind as you formulate your database mission statement, you may want to start the text the following way:\n\nThe purpose of the name of organization and/or organizational unit database is…\n\nThis way you are less likely to forget that the database is what matters here.\nIdeally, your database mission statement would be aligned with the organization’s mission for which it is intended, so having a good understanding of the organization’s mission is essential. In real life, this part of the database design process would likely involve conducting interviews with the key actors of the organization and across its different departments to ensure that you have a good idea of the needs that your database will be addressing. However, in the context of this course, you will not be conducting interviews. You will have to use your best judgment to ensure that your database mission statement is related to the organization’s mission. Also, since organizations usually state their missions on their website, you can certainly use that information to help you.\nIt should also be noted that the database that you will be proposing, and its mission statement, do not necessarily have to cover everything that an organization does. You could, for instance, choose to develop a database that would support the teaching mission of a university without considering or mentioning the other missions of the university, such as research.\nOther constraints present in the context of the course, but not in real life, are the minimum number of specific tasks that your database should be supporting (5) and the minimum number of required tables in your database design (10). You can use these requirements to gauge whether your mission statement is too narrow or too broad.\n\n2.3.1.1 A database for GummyBox\nGummyBox is a new online store specializing in the sale and delivery of gummies and gummy assortments. The organization needs a database to support its operations. The company has multiple divisions with their own data needs. The HR department deals with employee records and data on pay and benefits, the purchasing department deals with orders to the suppliers, and the sales team handles customers’ orders. We decide to design a database that will support the operations of the sales department, and so we decide to name the database gummybox_sales and to formulate its mission as follows:\n\nThe purpose of the gummybox_sales database is to manage the data needed by the sales department to attend to the customers’ sweet tooth.\n\nWhile it may seem a bit vague at first glance, this statement aligns with the organization’s mission and the operations of the sales department. The statement will thus provide some guidance as we get further in the database design process.\n\n\n\n2.3.2 Database objectives statement\nThe database objectives are general tasks supported by the database. One way to distinguish them from the database mission is to remember that the mission statement relates to what the organization does. In contrast, the database objectives relate to the specific tasks or needs of people inside the organization (e.g., employees) or outside the organization (e.g., clients or users). Here are some examples:\n\nKeep track of students progress in their programs\nMaintain vehicle inventory\nManage song collections\nManage team roster\nKeep track of players performance\n\nHere is a list of criteria to help you write a good objective statement:\n\nIt represents a single task.\nIt is clear.\nIt does not contain unessential details.\nIt states what the task is, but does not indicate how it will be done by the database.\n\n\n2.3.2.1 Objectives for the gummybox_sales database\nIt was decided, after consultation with the GummyBox team, that their database will have the following objectives:\n\nMaintain customer information.\nKeep track of orders.\nMaintain information on gummies.\nMaintain information on gummy assortments.\nCollect product reviews."
  },
  {
    "objectID": "relational_databases_part1.html#subjects-and-attributes",
    "href": "relational_databases_part1.html#subjects-and-attributes",
    "title": "2  Relational databases (Pt. 1)",
    "section": "2.4 Subjects and attributes",
    "text": "2.4 Subjects and attributes\nNow that we have established the mission and objectives that the database will be supporting, we need to ask ourselves two questions:\n\nWhat subjects (objects and events) are needed to fulfill the mission and objectives of the database? These objects and events constitute the subjects (or entities). If the mission is to support the activities of a job placement agency, your subject would likely include jobs, job-seekers, employers, and agents. For a university, you might want to include things like students, courses, instructors, and departments.\nWhat attributes of the subjects are needed to fulfill the mission and objectives of the database? This is where you list, for each of the subjects identified with the first question, the attributes that your database requires. one of the subjects of your database is customers, you would likely want to include their name, and possibly their email or phone number. But do you need their address? their social insurance number? the name of their first pet? There is no universal answer, and so you need to ask yourself this question for every table in your database, and answer it based on your judgement and the mission and objectives of the database.\n\nRelational databases don’t impose rules on the subjects and attributes that you can include in your database. It does however, impose rules on how these subjects and attributes must be captured in the form of tables (subjects) and fields (attributes).\n\n2.4.0.1 Subjects and attributes of the gummybox_sales database\nIf the objectives of your database are well formulated, they may already provide you with all the subjects that you need for your database. Here are the objectives of the gummybox_sales database in which I highlighted the subjects.\n\nMaintain customer information.\nKeep track of orders.\nMaintain information on gummies.\nMaintain information on gummy assortments.\nCollect procuct reviews.\n\nIdentifying subjects is no more complicated then that. I have five: customer, order, gummy, gummy assortments, and reviews.\n\n\n2.4.1 Database rules\nBefore we start building our database, it is important to identify or set rules that might constrain the values that an attribute can have for a single record or the relationships that can exist between two subjects.\nO important question to ask when conceptualizing your database is whether a single instance of a subject (e.g., a specific customer, a specific gummy, or a specific order) can have multiple values for the same attribute. Consider for instance, the customer subject of the gummybox_sales database. The attributes that we identified are the customer name, email and address. We may want to consider whether or not a customer should be able to have multiple addresses. We can also consider whether the database should be able to attribute multiple colours of flavours to the same gummy. These decisions are database rules that we can make specify like this:\n\nAn individual customer can have more than one addresses.\nAn individual gummy can have multiple colours\nAn individual gummy can have multiple flavours.\n\nWhen conceptualizing your database, it is also important to consider rules that apply to the relationship between subjects. For example, one of the subject in the gummybox_sales database is reviews. There are several decisions to make about reviews that may have an impact on the database design. Some relevant questions might be:\n\nDo we accept reviews from everyone or do we only accept reviews from registered customers?\nCan both individual gummies and gummy assortments be reviewed?\nCan a customer provide a review for orders or only for products?\nCan a customer review the same product multiple times?\n\nThe answer to these questions establish the nature of the relationship between the reviews and other subjects in the database such as gummies, gummy assortments, customers and orders. They also help ensuring that all the necessary attributes have been included.\nWe can also set rules to limit the specific values that an attribute can have. These rules are often implied in the database mission and objectives. For instance, if you are building a database of Electronic music and artists, it implies that other genres will not be included in the database. In this, case you could simply not consider genre at all in the attributes of our tables, or include a genre attribute with a rule specifying that the genre must be electronic. In the gummybox_sales database, we could decide to specify the different types of flavours that a gummy can have: sweet, salty, sour, bitter and umami.\nNot all elements of your database needs explicit rules, but it is important to think about them early on to prevent headaches later in the process. It is also important to remember that the rules are decisions determined by the practices and needs of the organization and the database. They are not meant to reflect the absolute reality. For example, while it is a fact that a person can have multiple addresses in real-life, we are free to decide to allow only one address per customer in our database. Similarly, if we have a country attribute in our database, we are not obligated to consider the entire set of countries that exist in the world. We can limit the set of possible countries according to our needs. These choices can also sometimes be made out of convenience when certain rules increase the complexity of a database without clear benefits.\nImportant note: The most important rules to consider, especially for this course, are whether or not records can have multiple values for the same attribute (e.g. can a customer have more than one address?) and those that define relationship between subjects (e.g., are only customers allowed to post product reviews?). These rules have direct implications for your database design. On the other hand, while they can play a crucial role data validation and quality insurance purposes, value-limiting rules (e.g. the list of values that the country attribute can have) have little to no implications for your design. It is also easy to get carried away and start defining rules for all attributes that could contain a specific set of values, so you should avoid doing that and use these rules parsimoniously. Besides, they are not mandatory for the database design that you will produce in this course.\nFinally, you should also avoid setting explicit rules when the relationship between subjects of your database is obvious. For instance, it is obvious that customers can place multiple orders and that orders can contain multiple products. Only define the rules when there are multiple suitable options for your design."
  },
  {
    "objectID": "relational_databases_part1.html#summary",
    "href": "relational_databases_part1.html#summary",
    "title": "2  Relational databases (Pt. 1)",
    "section": "2.5 Summary",
    "text": "2.5 Summary\nThis chapter covered all the steps that deal with conceptual questions related to our database (i.e., those that are external to the requirements of the relational model) and you and your teammates should now be equipped to identify:\n\nThe mission and objective of your database.\nThe objects and events are included in the database\nThe attributes of these objects and events that will be included in the database\nThe rules that specify the number or set of values that an attribute can have for a single record, and the relationships that exists between subjects.\n\nIn the next chapter we will get one step closer to our fully operational database by converting that information into a set of tables, fields, and relationships that follow the rules of the relational model."
  },
  {
    "objectID": "relational_databases_part1.html#homework",
    "href": "relational_databases_part1.html#homework",
    "title": "2  Relational databases (Pt. 1)",
    "section": "2.6 Homework",
    "text": "2.6 Homework\nWith your teammates:\n\nDefine the mission and objectives of your database.\nDetermine the subjects and attributes that will be considered in your database.\nDefine the database rules that will specify whether .\n\nYou can (but are not required) to use this template.\nRemember that the decisions you make at this point are not set in stone and that you will be able to revisit them as you build your database, so don’t aim for perfection (yet)!"
  },
  {
    "objectID": "relational_databases_part3.html#learning-objectives",
    "href": "relational_databases_part3.html#learning-objectives",
    "title": "4  Relational databases (Pt. 3)",
    "section": "4.1 Learning objectives",
    "text": "4.1 Learning objectives\nConcepts\n\nData types\nConstraints\n\nPractical skills\n\nSet data types and constraints for your fields."
  },
  {
    "objectID": "relational_databases_part3.html#slides",
    "href": "relational_databases_part3.html#slides",
    "title": "4  Relational databases (Pt. 3)",
    "section": "Slides",
    "text": "Slides\n\n\nFull screen slides"
  },
  {
    "objectID": "relational_databases_part3.html#data-types",
    "href": "relational_databases_part3.html#data-types",
    "title": "4  Relational databases (Pt. 3)",
    "section": "4.2 Data types",
    "text": "4.2 Data types\nEvery field you include in a table needs to have a data type. The data type is extremely important as it determines how the RDBMS will interpret, store, and potentially transform the data inserted in the tables. The data type also determines the types of operations that can be performed with the data it contains. The three basic data types are character, numeric, and dates and times.\n\n4.2.1 Character data types\nCharacter data types are very flexible because they can contain any combination of letters, numbers or symbols. The most common data types are CHAR, VARCHAR, NCHAR and NVARCHAR. The VAR prefix stands for variable, and the N prefix means national. You should use the CHAR data type when the length of the strings that you will store will not vary (ex., country codes, phone numbers, postal codes). The VARCHAR data type should be used when the length of the strings is expected to vary. Finally, the NCHAR and NVARCHAR should be used when the field is intended to store strings in multiple languages.\nWhen declaring a string variable type, you must specify the maximum length of the strings the database will store. For example, a field called gummy_name with a variable type VARCHAR(10) will not be able to store gummy names with more than ten characters.\nYou shouldn’t simply declare very large CHAR types to be safe and never have to worry about your data is too large for the field because that will either inflate the size of your table for no reason (which can matter a lot if it stores millions or billions of records) or will decrease the performance of your queries.\nMore information on the string data types can be found in the MySQL documentation.\n\n\n4.2.2 Numeric data types\nThe numeric data types store… you guessed it: numbers! You can use INT (for integer) or its variants for values that don’t require decimals. The only difference is the storage space they occupy and the range of value they can hold (see the summary in the table below). As for string data types, you want to use the smallest possible data type that can accommodate your data.\n\n\n\n\n\n\n\n\n\n\n\nType\nStorage (Bytes)\nMinimum Value Signed\nMinimum Value Unsigned\nMaximum Value Signed\nMaximum Value Unsigned\n\n\n\n\nTINYINT\n1\n-127\n0\n127\n255\n\n\nSMALLINT\n2\n-32768\n0\n32767\n65535\n\n\nMEDIUMINT\n3\n-8388608\n0\n8388607\n16777215\n\n\nINT\n4\n-2147483648\n0\n2147483647\n4294967295\n\n\nBIGINT\n8\n-263\n0\n263-1\n264-1\n\n\n\nFor values with decimals, you should use the FLOAT data type. However, the DECIMAL data type is preferred for financial data or other cases where having more than a certain number of decimals makes no sense (e.g., 2.3333$). The DECIMAL data type lets you specify the number of digits a value can have and how many of these digits are decimals. For instance, the DECIMAL(5,2) data type indicates that the field can contain values ranging from -999.99 to 999.99.\nMore information on the numeric data types can be found in the MySQL documentation.\n\n\n4.2.3 Date and time\nThe different date and time data types that you can use in MySQL are presented in the following table.\n\n\n\n\n\n\n\n\nData Type\nFormat\nRange\n\n\n\n\nDATE\n“0000-00-00”\n“1000-01-01” to “9999-12-31”\n\n\nTIME\n“00:00:00”\n“-838:59:59” to “838:59:59”\n\n\nDATETIME\n“0000-00-00 00:00:00”\n“1000-01-01 00:00:00.000000” to\n“9999-12-31 23:59:59.999999”\n\n\nTIMESTAMP\n“0000-00-00 00:00:00”\n“1970-01-01 00:00:01.000000” to\n“2038-01-19 03:14:07.999999”\n\n\nYEAR\n0000\n1901 to 2155\n\n\n\nAs you might notice from the table, no double quotes are used for the year format. That is because years are stored as numbers. It also has a very narrow range of possible values that allows the year to be very memory efficient since only one byte is necessary to store a range of 255 numerical values (see the TINYINT specifications in the previous table.\nThe difference between DATETIME and TIMESTAMP is that the TIMESTAMP converts the value to UTC and is converted back into local time when retrieved. With the DATETIME format, values are stored and retrieved as is.\nMore details on the date and time formats can be found in the MySQL documentation.\n\n\n4.2.4 Other data types\nThe supported data types vary for different RDBMS, but these systems are constantly evolving and expanding the data types they can handle. For example, possibly in response to the growing popularity of the JSON file format, MySQL now supports the JSON data type. More information on this data type and how to use it can be found in the MySQL documentation. You might remember that we played with the JSON format a little bit at the beginning of the course. However, please note that knowing how to use the JSON data type in MySQL is beyond the scope of the course. For our current purpose, it is enough to be aware of the fact that while MySQL databases are usually used for structured data, they are flexible tools that can deal with all kinds of semi-structured data formats (like JSON) and unstructured data (like plain text, and binary files like images, videos, etc.)."
  },
  {
    "objectID": "relational_databases_part3.html#constraints",
    "href": "relational_databases_part3.html#constraints",
    "title": "4  Relational databases (Pt. 3)",
    "section": "4.3 Constraints",
    "text": "4.3 Constraints\nSQL constraints are used to specify rules for data in a table. They are used to preserve the integrity of the database, ensure data quality, and prevent data loss. While you do not need to use constraints other than the PRIMARY KEY and the FOREIGN KEY ones for this course, it is helpful to know about constraints and what they do. Here is a list of constraints that are available in MySQL databases.\n\nPRIMARY KEY: As you already know, the PRIMARY KEY must be unique and cannot be empty. The RDBMS also automatically creates an index (explained below) on this field.\nNOT NULL: Specifies that this field must always contain a value and cannot be empty (NULL).\nUNIQUE: A field with a UNIQUE constraint cannot contain duplicate values.\nAUTO INCREMENT: These constraints can be used with numeric data types and are particularly useful for your primary keys. It means that whenever a new record is created, this field will automatically contain a value 1+the highest value contained in that field. This way, you don’t need to provide value for the field, and you don’t have to worry about duplication.\nGENERATED: This constraint allows you to automatically generate a value for the field upon creating a new record. It is similar to AUTO INCREMENT, except that you can decide how the value is generated, for instance, by concatenating the first_name and last_name column to generate a full_name value.\nFOREIGN KEY: the value inserted into a FOREIGN KEY must exist in the PRIMARY KEY field of the parent table. NULL values are allowed in FOREIGN KEY fields.\nCHECK: the check constraint is a very flexible constraint that allows you to specify the specific values that a field can contain. For example, you could set a CHECK constraint on the number of gummies in an order specifying that the value must be greater than 0.\nDEFAULT: This constraint defines a default value to be inserted in the field when a new record is created, and no value is provided for that specific field.\nINDEX: This constraint is used to create an index for the values of that field, which can dramatically increase the speed of your queries. Just like an index at the end of a book telling you on what page(s) you can find information about a particular concept or topic instead of having to look at each page to find those sections, the MySQL INDEX creates a list of records where each of the different values of that field can be found and stores that list into its memory, so that those records can be retrieved much faster. So, for example, if you have 50 different gummy records in your gummy table, 12 of which are red, 25 are blue, and 13 are green, you could create an index on the gummy_color table. The index would have one record for each colour (red., blue, green), each containing a list of the gummy_id that has that colour.\n\n\n4.3.1 Index example\nIf you ask the database to retrieve the blue gummies from the gummy table and you do not have an inde on the colour column, it has to scan each row, to see the colour is “blue”, if the table as 1 million rows, then this verification has to be done 1 million times.\nNo index on the colour field of the gummy table\n\nWith an index on the colour field of the gummy table\nIf you ask the database to retrieve the blue gummies from the gummy table, and have an index on the colour column. The database scans the index until it finds the colour “blue” and and then fetches the rows of the gummy table with that are blue. If there are 50 possible colours, then the database has to scan between 1 and 50 rows (depending when it finds the value “blue”)."
  },
  {
    "objectID": "relational_databases_part3.html#documenting-your-database",
    "href": "relational_databases_part3.html#documenting-your-database",
    "title": "4  Relational databases (Pt. 3)",
    "section": "4.4 Documenting your database",
    "text": "4.4 Documenting your database\nNow that you have a complete database designed, with tables, fields with all the appropriate data types and constraints. You are ready to move to the next step: documentation.\nAdequately documenting your database is crucial because it ensures that the users will be able to understand what tables contain, why they exist, and how to use your database. You already know (and have applied) best practices for table and field names. That likely reduces the need for your database users to refer to the documentation all the time, but it does not eliminate the need for it. Describing your tables and fields also helps ensure they are needed and well-designed. If you cannot describe the purpose of a table, it may be that it has, in fact, no purpose.\nHere are a few simple rules to follow:\n\nClearly and concisely describe the tables and fields.\nFor tables only, your description should provide some indication of its purpose (why it is necessary).\nFocus on the content of the tables or fields rather than how they will specifically be used or accessed and by whom.\nDo not use examples in your descriptions."
  },
  {
    "objectID": "relational_databases_part3.html#exercises",
    "href": "relational_databases_part3.html#exercises",
    "title": "4  Relational databases (Pt. 3)",
    "section": "4.5 Exercises",
    "text": "4.5 Exercises\nAs an exercise for this week, I invite you to connect to your team’s database on the qsslab MySQL server (using the connection information that you received by email) and to experiment with data types and constraints by creating your tables, inserting data into those tables, and then retrieving the content of the tables to see how your data was stored. Because you cannot break the database and the worst thing that can happen is that your queries return an error, don’t be afraid to try crazy queries that you know should not work (for instance, storing the string “abcd” in a DATETIME field), just to see how SQL reacts. That said, please limit your queries to CREATE, INSERT, SELECT and DROP statements at this point."
  },
  {
    "objectID": "relational_databases_part2.html#learning-objectives",
    "href": "relational_databases_part2.html#learning-objectives",
    "title": "3  Relational databases (Pt. 2)",
    "section": "3.1 Learning objectives",
    "text": "3.1 Learning objectives\nConcepts\n\nTable and fields\nTable types\nRelationship types\nEntity-Relationship Diagrams\n\nPractical skills\n\nCreate an Entity-Relationship Diagram (team assignment #2)\nOptimize the structure of your database (team assignment #2)"
  },
  {
    "objectID": "relational_databases_part2.html#introduction",
    "href": "relational_databases_part2.html#introduction",
    "title": "3  Relational databases (Pt. 2)",
    "section": "3.2 Introduction",
    "text": "3.2 Introduction\nUntil now, we have been thinking about database and its subjects, attributes and rules without considering their implementation in an actual relational database and the additional rules that relational databases impose on our design. In this chapter, we will begin to transform our database subjects, attributes and rules into a database model with tables, fields and relationships."
  },
  {
    "objectID": "relational_databases_part2.html#tables-and-fields",
    "href": "relational_databases_part2.html#tables-and-fields",
    "title": "3  Relational databases (Pt. 2)",
    "section": "3.3 Tables and fields",
    "text": "3.3 Tables and fields\nWe already know from the short introduction to relational databases in the previous chapter that our subjects are represented as tables and their attributes as fields (columns) in those tables. However, because of the rules of relational database design, converting subjects to tables and attributes to fields is not simply a matter of changing the labels in the design.\nHere are the two most important rules to follow when creating tables:\n\nEach table represents a single subject. Gummies and their attributes are stored in one table, orders in another, customers in another, and so on. The set of fields in a table defines the subject, and it would make no sense for a subject to be defined by a gummy name, description, flavour, price as well as by a customer name, a delivery address and a phone number. When adding fields to a table, it is important to ask whether the fields are defining characteristics of the subject represented. Some associative tables (we explain what those are below) can be created for the specific purpose of capturing the relationship between two other tables or accommodate the possibility for an attribute to have multiple values for the same record. Such tables are exceptions as their function is not to represent subjects.\nEach table has at least one field that will be the primary key. The primary key is a unique identifier for each record stored in the table (the same primary key cannot appear twice in the table). The primary key is also used to reference a record from one table in another table. The field that makes the reference is called a foreign key. For instance, in the gummybox_sales database, customers will be represented in a customer table that contains a primary key named id. Records in another table (e.g., the order table) might need to indicate which customer placed the order. Rather than repeating all the customer information in the order table, each record instead simply needs to includes the id of the customer. In the order table we would then have a field named customer_id that would be a foreign key (i.e., the primary key of another table).\n\nThere are also several important principles that fields should follow:\n\nEach field should be unique in the entire database (except foreign keys). You should avoid repeating the same fields in different tables. For instance, if country is an attribute of more than one subject in your database, you should consider using a validation table (we explain what those are below) called country and include in your other tables a foreign key referencing the country table.\nEach field represents a distinct attribute of the subject. A field should not combine, for example, the birth date and the age, the height and weight and any other attributes of the subject. Each attribute has its field.\nEach field contains a single value that cannot be deconstructed into smaller ones. The name of a person is an example of a field that can be deconstructed into smaller ones (e.g., first name and last name).\nFields should not contain calculated values. For instance, we could be tempted to include the total price for an order in an order table. However, this would most likely not be optimal if the total price of an order can be calculated by multiplying the number of units included in the order by their individual price.\n\n\n3.3.1 Naming tables and fields\nHernandez (2013) proposes some guidelines for naming your tables and fields to make your database easier to understand and navigate. The table below includes all of Hernandez’s recommendations except that we should use the plural form for table names and the singular form for field names. Instead, I recommend using the singular for both table names and field names.\nCharacteristics of a good table and field names\n\n\n\n\n\n\n\n\nRule\nBad\nGood\n\n\n\n\nAccurate, unique, and meaningful to the organization\nTableA\nEmployee\n\n\nRefers to a single subject (unless it is an associative table)\nFaculties/Departments\nMake two tables\n\n\nAs short as possible\nCoursesOffered\nCourse\n\n\nDo not use words like list, records, data\nCoursesList\nCourse\n\n\nDoes not use acronyms\nSRI\nStudent_Ratings_of_Instruction\n\n\nDoes not unduly restrict the data that can be entered into the table\nFall_course\nCourse\n\n\nUse the singular form\nCourses\nCourse\n\n\n\n\n\n3.3.2 Table types\nThere are three basic table types that you will encounter in your database:\n\nData tables typically represent the main subjects of your database (e.g., objects, people, events). They usually have a single primary key, and they gather data that provides information about the subject represented in the table.\nAssociative tables create associations between the subjects in your database (e.g., students-courses, products-orders, customers-orders). They have typically had multiple foreign keys that together will form the composite primary key. Some, but not all, of the main subjects of a database design can be associative tables.\nValidation tables (lookup tables) are used for data quality and validation purposes. They contain the list of possible values that a field can take. For instance, your grade for this class has a limited set of possible values (A+, A, A-, B+, B, B-, F, AUD, ILL, INC, IP, P). A validation table can but does not have to be used to store these possible values to ensure that a user cannot enter the grade “G” or “Banana” in the grade field of the database. Validation tables are also useful for reducing the memory requirement of your database. You can replace large data types, such as character strings, with smaller data types, such as numbers. We will learn more about data types in the next chapter."
  },
  {
    "objectID": "relational_databases_part2.html#relationship-types",
    "href": "relational_databases_part2.html#relationship-types",
    "title": "3  Relational databases (Pt. 2)",
    "section": "3.4 Relationship types",
    "text": "3.4 Relationship types\nRelationships are critical determinants of the structure of your database. They are represented by foreign keys in some of your tables linked to other tables’ primary keys. Luckily, relationships are a relatively simple concept that is easy to implement in your database design process. There are only three basic kinds of relationships, so let’s take a quick look at them.\n\n3.4.1 One-to-one relationship\nThis relationship exists when one record in a table can only be associated with one record in another table and vice versa. A one-to-one relationship may exist, for instance, between the office space and the personnel of an organization, as long as nobody is allowed to share an office or to have two offices. These relationships are rare in reality since it often makes more sense to bring back to combine tables with one-to-one relationships in a unique table. However, there are situations where the use of one-to-one relationships can be required or appropriate, for example:\n\nSecurity: you may want to store sensitive information about an individual in a different table that only some authorized users can access.\nSemantics: even though you could include information about the office space in your employees table, you might not want to store information about your offices with your employees table. First names, last names and birth dates are characteristics of people, but buildings and room numbers are not.\n\n\n\n3.4.2 One-to-many relationship\nA one-to-many relationship exists when one record in a table can be associated with one or more records in another table. It is the most frequent type of relationship in properly designed databases. A typical example is the customers table and the orders table. A single customer record can be associated with multiple orders, but only one customer can be associated with a specific order.\n\n\n3.4.3 Many-to-many relationship\nMany-to-many relationships exist when one record in a table can be associated with multiple records in another table and vice versa. A typical example is a product that can be part of multiple orders and an order that can contain multiple products. Another example is the relationship between university courses and students. A single course can have multiple students. Inversely, a single student can be enrolled in multiple courses.\n\n3.4.3.1 Issues with many-to-many relationships\nThese relationships are widespread in the world, and they are great. However, they also raise potential issues that need to be resolved in your database design. By definition, these relationships imply that the non-duplication of the primary key rule will be violated so that something that your RDBMS will not allow.\n\nOne solution for that is to use a composite primary key. This means your table has two or more primary keys instead of one. In practice, that means that every combination of the two fields forming the key are not allowed to be repeated in the table.\n\nHowever, the composite key solution is often not optimal since it can create a lot of redundancy in your table, which you want to minimize as much as possible.\n\nThat is the purpose of associative tables. They are tables created with the specific purpose of linking your subjects together to prevent primary key duplication and minimize redundancy.\n\nNow the Melvil Dewey information is not repeated in the database for every course they are registered for. In fact, none of the information is repeated other than the primary and foreign keys."
  },
  {
    "objectID": "relational_databases_part2.html#entity-relationship-diagrams",
    "href": "relational_databases_part2.html#entity-relationship-diagrams",
    "title": "3  Relational databases (Pt. 2)",
    "section": "3.5 Entity-relationship diagrams",
    "text": "3.5 Entity-relationship diagrams\nAn entity-relationship diagram (ERD) is a visual representation of your database that typically includes every table along with their fields and the relationship between them. The ERD is a helpful tool for designing your database because it helps you visualize your table and fields and their relationship, making it easier to spot mistakes and inconsistencies. It is also a valuable part of your database documentation as it can give users a good understanding of the data to use it more effectively. The video below demonstrates how to draw ERDs using diagrams.net (formerly draw.io).\n\n\n\n\n\n\nImportant\n\n\n\nYou should watch the video even if you already know how to use diagrams.net or are not planning to use it for the course. It provides general guidance on ERD and database design.\n\n\n\n\n\n3.5.1 Other tools to make your entity-relationship diagram\n\n3.5.1.1 Whiteboard\nWhen you are at the very early stages of your design and still very unclear about what your tables may look like, it can be a good idea to try things out on a whiteboard (or paper) to get a quick sense of what works and what doesn’t."
  },
  {
    "objectID": "relational_databases_part2.html#homework",
    "href": "relational_databases_part2.html#homework",
    "title": "3  Relational databases (Pt. 2)",
    "section": "3.6 Homework",
    "text": "3.6 Homework\nThe homework for this week is to start designing your database with your teammates and to begin working on the individual lab #2."
  },
  {
    "objectID": "relational_databases_part2.html#appendix-a---installing-mysql-workbench",
    "href": "relational_databases_part2.html#appendix-a---installing-mysql-workbench",
    "title": "3  Relational databases (Pt. 2)",
    "section": "3.7 Appendix A - Installing MySQL Workbench",
    "text": "3.7 Appendix A - Installing MySQL Workbench\nImportant: while the latest version of MySQL Workbench (8.0.28) will work to design your database model. It is not supported by the MySQL server that you can use to go live with your database, add data to it, and write SQL queries to retrieve it. Using the live server is not required in the course but strongly recommended, so you should install MySQL Workbench 8.0.27 or an earlier version.\nTo install MySQL Workbench on your computer, go to https://dev.mysql.com/downloads/workbench/\nThen choose archives to access previous versions.\n\n\nYou will be asked if you want to sign up for an Oracle web account. You do not need to sign up. Simply click on “No thanks, just start my download” (as show in the image below)."
  },
  {
    "objectID": "relational_databases_part2.html#appendix-b---the-gummybox_sales-erd",
    "href": "relational_databases_part2.html#appendix-b---the-gummybox_sales-erd",
    "title": "3  Relational databases (Pt. 2)",
    "section": "3.8 Appendix B - The gummybox_sales ERD",
    "text": "3.8 Appendix B - The gummybox_sales ERD\n\n\n\n\n\nHernandez, Michael J. 2013. Database Design for Mere Mortals: A Hands-on Guide to Relational Database Design. Third edition. Upper Saddle River, NJ: Addison-Wesley."
  },
  {
    "objectID": "relational_databases_part2.html#appendix-a---installing-pgadmin",
    "href": "relational_databases_part2.html#appendix-a---installing-pgadmin",
    "title": "3  Relational databases (Pt. 2)",
    "section": "3.7 Appendix A - Installing pgAdmin",
    "text": "3.7 Appendix A - Installing pgAdmin\nTo install pgAdmin on your computer, go to https://dev.mysql.com/downloads/workbench/"
  },
  {
    "objectID": "relational_databases_part2.html#section",
    "href": "relational_databases_part2.html#section",
    "title": "3  Relational databases (Pt. 2)",
    "section": "3.7 ",
    "text": "3.7 \n\n\n\n\nHernandez, Michael J. 2013. Database Design for Mere Mortals: A Hands-on Guide to Relational Database Design. Third edition. Upper Saddle River, NJ: Addison-Wesley."
  }
]