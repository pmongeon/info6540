[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Data Management",
    "section": "",
    "text": "Course overview\nThis course (and this accompanying website) are designed to provide you with a practical introduction to data management. It is a hands-on course in which you will get comfortable working with data, with a focus on data structures and database design. After completing this course, you hopefully will have a better understanding of how data infrastructures support the organizations, websites and applications that we use everyday, and feel confident in your ability to work with data and design effective databases that meet the needs of your users."
  },
  {
    "objectID": "index.html#schedule",
    "href": "index.html#schedule",
    "title": "Data Management",
    "section": "Schedule",
    "text": "Schedule\nThe class will be on Wednesday from 2:35 pm to 5:25 pm in the Sir James Dunn building, room 301A.\nAdditional lab time and support will be available Tuesday afternoons, from 1:00 pm to 4:00 pm, at Rowe 4025.\nIf you wish to book a meeting with me on Teams or outside of office hours, please use this link.\n\n\n\n\n \n  \n    Date of Class \n    Topics \n  \n \n\n  \n    Week 1 (Jan 11) \n    Course overview \n  \n  \n    Week 2 (Jan 18) \n    Thinking about data \n  \n  \n    Week 3 (Jan 25) \n    Relational model \n  \n  \n    Week 4 (Feb 1) \n    Relational model \n  \n  \n    Week 5 (Feb 8) \n    Relational model \n  \n  \n    Week 6 (Feb 15) \n    Relational database management systems \n  \n  \n    Reading week (Feb 22) \n     \n  \n  \n    Week 7 (Mar 1) \n    Structured Query Language (SQL) \n  \n  \n    Week 8 (Mar 8) \n    Structured Query Language (SQL) \n  \n  \n    Week 9 (Mar 15) \n    Free lab time \n  \n  \n    Week 10 (Mar 22) \n    Document databases \n  \n  \n    Week 11 (Mar 29) \n    Graph databases \n  \n  \n    Week 12 (Apr 5) \n    Course wrap-up"
  },
  {
    "objectID": "index.html#assignments",
    "href": "index.html#assignments",
    "title": "Data Management",
    "section": "Assignments",
    "text": "Assignments\n\n\n\n\n \n  \n    Component \n    Details \n    Due date \n    Value \n  \n \n\n  \n    Lab 1 \n    Excel \n    2023-01-31 \n    5% \n  \n  \n    Group project part 1 \n    Mission statement and objectives \n    2023-02-03 \n    5% \n  \n  \n    Lab 2 \n    Entity-relationship diagram \n    2023-02-21 \n    10% \n  \n  \n    Group project part 2 \n    Database design \n    2023-03-03 \n    25% \n  \n  \n    Lab 3 \n    SQL \n    2023-03-14 \n    5% \n  \n  \n    Group project part 3 \n    SQL and database views \n    2023-03-17 \n    10% \n  \n  \n    Lab 4 \n    JSON \n    2023-03-28 \n    5% \n  \n  \n    Participation \n    Team assessment \n    2023-03-31 \n    10% \n  \n  \n    Assignment 2 \n    Build your own ontology \n    2023-04-14 \n    25%"
  },
  {
    "objectID": "index.html#official-syllabus",
    "href": "index.html#official-syllabus",
    "title": "Data Management",
    "section": "Official syllabus",
    "text": "Official syllabus\n\n\n\nThis browser does not support PDFs. Please download the PDF to view it: <a href=“files/syllabus/INFO6540_Syllabus.pdf”>Download PDF</a>."
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "This is a book created from markdown and executable code.\nSee Knuth (1984) for additional discussion of literate programming.\n\n1 + 1\n\n[1] 2\n\n\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "2  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever.\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Hernandez, Michael J. 2013. Database Design for Mere Mortals: A\nHands-on Guide to Relational Database Design. Third edition. Upper\nSaddle River, NJ: Addison-Wesley."
  },
  {
    "objectID": "introduction.html#learning-objectives",
    "href": "introduction.html#learning-objectives",
    "title": "1  Thinking about data",
    "section": "1.1 Learning objectives",
    "text": "1.1 Learning objectives\n\nUnderstanding the concepts of data, dataset, database, data management, and data management systems.\nUnderstanding the difference between unstructured, semi-structured, and structured data."
  },
  {
    "objectID": "introduction.html#what-is-data",
    "href": "introduction.html#what-is-data",
    "title": "1  Thinking about data",
    "section": "1.2 What is data?",
    "text": "1.2 What is data?\nThe Merriam-Webster online dictionary provides three definitions of the word data:\n\nfactual information (such as measurements or statistics) used as a basis for reasoning, discussion, or calculation.\n\n\ninformation in digital form that can be transmitted or processed\n\n\ninformation output by a sensing device or organ that includes both useful and irrelevant or redundant information and must be processed to be meaningful\n\n— Merriam-Webster dictionary\n\n\nTogether, these definitions offer us a set of key elements from which we can build a broad understanding of the concept of data. The first key term is factual information or fact suggesting that data is objective and, like the rest of the definition shows, is used for a given purpose, such as discussing reasoning or decision-making.\nThe second definition is related to using the word data in a computational or communicational sense, where data is the “thing” that is being stored, transmitted, received, processed, etc.\nWhile the first definition suggests that humans and machines use data for processes such as decisions and calculations, the third definition highlights that data does not only exist in nature but can also be created by humans and machines, either purposefully or not.\nWhile we often think of data as things found in spreadsheets and stored in computers or filing cabinets, data is much more than that. Data is everywhere around us all the time in the form of energy and sound or light waves, for instance. Our sensory organs are data captors that pick up data from our environment. Our brains process, structure, and possibly store the data so we can consciously or unconsciously use it now or later as a basis for decisions and actions. That said, in this course, we will not concern ourselves with this kind of data and process. Instead, we will focus on digitally recorded data, the kind that we can store in a computer."
  },
  {
    "objectID": "introduction.html#datasets",
    "href": "introduction.html#datasets",
    "title": "1  Thinking about data",
    "section": "1.3 Datasets",
    "text": "1.3 Datasets\nWe often encounter the term “dataset” on the web or in our workplaces, and I think it is worth writing a few lines to relate the terms to the other terms we will use in this course. The terms data and dataset will often be used interchangeably since dataset literally means a set of data, and data is the plural of datum. One difference, in principle, is that datasets are usually assembled for a given purpose. In research, for instance, a dataset will be the exact collection of data collected for the analysis. In supervised machine learning, we distinguish between training and testing datasets. When a professor sends you an excel file with data to work with for an assignment, that’s a dataset. You find datasets when you browse websites like kaggle.com, zenodo.org, or dataverse.org. Datasets are also static, whereas databases can be dynamic."
  },
  {
    "objectID": "introduction.html#databases",
    "href": "introduction.html#databases",
    "title": "1  Thinking about data",
    "section": "1.4 Databases",
    "text": "1.4 Databases\nWhat is a database? According to the Merriam-Webster dictionary, a database is “a usually large collection of data organized especially for rapid search and retrieval (as by a computer)”. The keyword here is organized, highlighting that databases are both products and tools for data management.\nDatabases are usually created and managed for some purposes. These purposes may be specific (e.g. keeping track of a store’s inventory) or broad (tracking socioeconomic trends). Depending on their purposes, databases can vary in size and complexity. Any organized data collection could be considered a database, even if it is as basic as an Excel spreadsheet with the names and addresses of your friends or your to-do list.\nA database can contain or be used to create multiple datasets, but a dataset would typically not contain multiple databases. Of course, this does not mean that datasets are always drawn from databases. For example, datasets can be created by surveying or interviewing people or recording observations of natural phenomena.\nNote, however, that those differences are not hard truths, as some datasets may serve a greater variety of users and purposes than some databases."
  },
  {
    "objectID": "introduction.html#database-management-systems-dbms",
    "href": "introduction.html#database-management-systems-dbms",
    "title": "1  Thinking about data",
    "section": "1.5 Database management systems (DBMS)",
    "text": "1.5 Database management systems (DBMS)\nA Database Management System (DBMS) is software that supports the development, maintenance, security, and use of databases. You will often come across the DBMS acronym with different suffixes attached to it, such as RDBMS (Relational DBMS), OODBMS (Object-Oriented DBMS), or ORDBMS (Object-Relational DBMS). Note that all these DBMS generally offer the same basic features. The main difference is that they work with different data types and structures. In this course you will use one RDBMS called pgAdmin to put implement your database design on a live server. You will also be introduced to the two popular DBMSs: MongoDB and Neo4j for document databases and graph databases, respectively.\nMost DBMS are pretty easy to get started with, and some will provide standard templates for tables and data structures. But as Hernandez (2013) writes in the introduction of their popular database design book, diving in without proper preparation and relying too much on templates is an easy way to end up with a design that is inefficient or does not work. A bad database design will lead to data problems such as missing, incorrect, or mismatched data. It will fail to play its role in supporting the organization or serving the users."
  },
  {
    "objectID": "introduction.html#data-management",
    "href": "introduction.html#data-management",
    "title": "1  Thinking about data",
    "section": "1.6 Data management",
    "text": "1.6 Data management\nSo far in this chapter, we explored the concepts of data and its different levels of structure, datasets, databases and data management systems. Aside from related to data, what do all these concepts have in common? They are what data managers work with. Data managers unlock the potential of data for a given purpose, individual, group or organization, by developing and implementing data strategies and processes such as data retrieval, processing, cleaning, storage and analysis.\nThe value of data depends on the purpose it serves. Thus, good data management requires a good understanding of both the data and the needs of its users so that optimal data strategies can be developed and implemented. In this course, you will get familiar with several tools to manage data and data-related processes and design a database that addresses the needs of an organization or group."
  },
  {
    "objectID": "introduction.html#from-unstructured-to-structured-data",
    "href": "introduction.html#from-unstructured-to-structured-data",
    "title": "1  Thinking about data",
    "section": "1.7 From unstructured to structured data",
    "text": "1.7 From unstructured to structured data\nData can take many forms that we can situate along a continuum with unstructured data at one extreme, structured data at the other, and semi-structured data in between. Let us consider a simple example to better grasp the difference between structured and unstructured data and, at the same time, to get a sense of the process of structuring data so that it can be more effectively strored and analyzed.\nHere is a brilliant piece of writing:\n\nA data story\nPhilippe Mongeon\nChapter 1\nOnce upon a time, a random internet user created a short text and abandoned it in a sea of unstructured data.\nChapter 2\nAn algorithm passed by and decided to add XML tags to the text.\nChapter 3\nA data manager stumbled upon the data and thought it would be relevant for the database users. So they decided to add it to their relational database.\nThe end.\n\nThat’s unstructured data (not entirely, the line breaks are a very basic structure). We humans who have read a book before can see the structure, but for a computer, this is just text. So now, let us give this text a little bit more structure by applying XML tags.\n\n<book>\n<title>A data story</title>\n<author>Philippe Mongeon</author>\n<h1>Chapter 1</h1>\n<p>Once upon a time a short text was created by a random internet user and abandoned in a sea of unstructured data.</p>\n<h1>Chapter 2</h1>\n<p>An algorithm passed by and decided to add xml tags to the text.</p>\n<h1>Chapter 3</h1>\n<p>A data manager stumbled upon the data, thought it would be relevant for the database users, and so she decided to add it to include it in her relational database.</p>\n<p>The end.</p>\n</book>\n\nThe XML tags already help us (and the computer) identify different text components, such as the title, the author, headers and paragraphs. XML documents are a typical example of semi-structured data.\nAnother frequently used semi-structured format is JSON, which in this case would look like this:\n\n{\n  \"title\": \"A data story\",\n  \"author\": \"Philippe Mongeon\",\n  \"Chapter 1\": \"Once upon a time a short text was created by a random internet user and abandoned in a sea of unstructured data.\",\n  \"Chapter 2\": \"An algorithm passed by and decided to add xml tags to the text.\",\n  \"Chapter 3\": \"A data manager stumbled upon the data, thought it would be relevant for the database users, and so she decided to add it to her relational database. The end.\"\n}\n\nNotice how I included the Chapter number in the tags here in this example? That was an arbitrary choice, and I could have chosen another structure for my file, such as this one:\n\n{\n  \"title\": \"A data story\",\n  \"author\": \"Philippe Mongeon\",\n  \"Chapters\": [\n      {\n        \"title\": \"Chapter 1\",\n        \"content\": \"Once upon a time a short text was created by a random internet user and abandoned in a sea of unstructured data.\"\n      }\n      {\n        \"title\": \"Chapter 2\",\n        \"content\": \"An algorithm passed by and decided to add xml tags to the text.\"\n      }\n      {\n        \"title\": \"Chapter 3\",\n        \"content\": \"A data manager stumbled upon the data, thought it would be relevant for the database users, and so she decided to add it to her relational database. The end.\"\n      }\n  ]\n}\n\nThis structure (or semi-structure) is just as good as the previous one. That flexibility is one of the reasons why semi-structured data formats and databases are growing in popularity. Because the data structure is included directly in the document, the users do not need to follow a predefined structure and use predefined tags to store their data in the database. This means that, theoretically, every record could have a different structure, which would be fine, but most likely not optimal. We will explore this type of structure and a popular DBMSs that uses it (MongoDB) later in the course.\nStructured data and databases are typically tabular (like an Excel spreadsheet). Each row is a record or entry, and each column is a field, feature, variable, etc. The structure is part of the database design (and not each database entry, as in the semi-structured format), and so every new record has to follow that same format. For example, here is the same work of art in a structured format.\n\n\n\n\nExample of structured data\n \n  \n    Title \n    Author \n    Section \n    Content \n  \n \n\n  \n    A data story \n    Philippe Mongeon \n    Chapter 1 \n    Once upon a time a data was created by a random internet user and abandoned in a see of unstructured data. \n  \n  \n    A data story \n    Philippe Mongeon \n    Chapter 2 \n    An algorithm passed by and decided to add xml tags to the text. \n  \n  \n    A data story \n    Philippe Mongeon \n    Chapter 3 \n    A data manager stumbled upon the data, thought it would be relevant for the database users, and so she decided to add it to include it in her relational database. The end. \n  \n\n\n\n\n\nHere, the structure is determined by the columns I chose for my table (title, author, section, and content). But, again, this was an arbitrary choice, and I could have chosen a completely different structure (although the realm of possibilities is somewhat limited by the data and by common sense). The point is that there is rarely an absolute best way of structuring data, and the best structure is the one that best suits the needs of the users. Sometimes the same data may be duplicated and structured differently to suit different users and uses.\nPerhaps you noticed that the title and author information is repeated in this last example, which is not a great database design. This course will teach you how to avoid such redundancies and design sound and efficient relational databases. We will talk about the relational model later in the course, but for now, note that relational databases are types of databases that follow a set of rules and principles that make them best suited for structured data."
  },
  {
    "objectID": "introduction.html#practice",
    "href": "introduction.html#practice",
    "title": "1  Thinking about data",
    "section": "1.8 Practice",
    "text": "1.8 Practice\nOver the next few weeks of the course, you will design a relational database, store data into it, and write SQL queries to retrieve data. But since this course is intended to be accessible to students with little to no experience working with data, this week is dedicated to developing or polishing your Microsoft Excel skills.\nWhile Excel has some data management capabilities, that’s not what it is designed and most commonly used for. You can still think of it as a very rudimentary form of DBMS. However, Excel is a flexible tool that you can use to quickly explore, manipulate and structure data before creating those structures in an actual DBMS. Excel will also always be relevant in your data management workflow because it remains one of the most accessible ways to work with data for downstream processes (before data gets stored in a DMBS) and upstream processes (after the data is retrieved from the DBMS).\n\n1.8.0.1 Formatting exercise\n\nDownload the Easy_Excel.xlsx file (provided by Julie Marcoux, a data librarian at the Killam Library)\nFollow the instructions in the instructions sheet.\nThe exercise sheet contains the data to format.\nAt the end of the exercise, your table should look similar to the one found in the Results sheet.\nThe Useful functions sheet contains tips on using some Excel formatting functions.\n\n\n\n1.8.0.2 Analyzing exercise\n\nWatch the demo on pivot tables in Excel below.\nCreate a pivot table to explore the data in the _The exercise sheet of the Easy_Excel.xlsx used for the first exercise.\nExplore ways of structuring your pivot table and combining and filtering columns.\nWhich publisher has the most books in the dataset?\nOn average, are cloth-bound books more or less expensive than paper-bound books?\n\n\n\n\n\n\n\nHernandez, Michael J. 2013. Database Design for Mere Mortals: A Hands-on Guide to Relational Database Design. Third edition. Upper Saddle River, NJ: Addison-Wesley."
  },
  {
    "objectID": "relational_databases_part1.html#learning-objectives",
    "href": "relational_databases_part1.html#learning-objectives",
    "title": "2  Relational databases (Pt. 1)",
    "section": "2.1 Learning objectives",
    "text": "2.1 Learning objectives\nConcepts\n\nMission and objectives statements\nRelational databases\nSubjects and attributes\nDatabase rules\n\nPractical skills\n\nWriting a mission and objectives statement for your database (team assignment #1) \nCreating database tables and fields (team assignment #2) \nDocumenting databases (team assignment #2)"
  },
  {
    "objectID": "relational_databases_part1.html#what-is-a-relational-database",
    "href": "relational_databases_part1.html#what-is-a-relational-database",
    "title": "2  Relational databases (Pt. 1)",
    "section": "2.2 What is a relational database?",
    "text": "2.2 What is a relational database?\nRelational databases store relations that are represented as tables. Each column of a table is an attribute (also called field, column, variable or feature). I will call fields from now on), and tuples (or records) are a set of attributes. For example, consider the table below, which is a set of relations representing students. Each record is a unique student defined by four attributes: their student ID, first name, last name, and program. The subject represented in this table are the students, and the same set of limited features represents all the students. No student can exist in this database with different features than the others. A relational database is a collection of tables linked to one another, each representing a different subject (courses, buildings, animals, concerts, orders, conversations, families, foods, games, or anything that we wish to capture in the database), and each with their own set of fields, and records.\n\nThe figure below shows how tables are linked to one another in the relational model.\n\nIn the next few weeks, you will learn how to design your own relational database, so let’s get started."
  },
  {
    "objectID": "relational_databases_part1.html#mission-and-objectives",
    "href": "relational_databases_part1.html#mission-and-objectives",
    "title": "2  Relational databases (Pt. 1)",
    "section": "2.3 Mission and objectives",
    "text": "2.3 Mission and objectives\nAs I mentioned in the opening chapter of this book, databases are created for a specific purpose, and that purpose should be clearly defined before you start creating tables and fields and their relationships. This is the first step of the database design process that Hernandez (2013) proposes in his book, so let us start there are well.\n\n2.3.1 Database mission statement\nThe database mission statement is a short text written in general and accessible language that states the specific purpose of your database. It is important to note that it is not the same as the organization’s mission statement for which the database will be designed. Instead, this statement refers specifically to the database and what the database will do for the organization. To keep that in mind as you formulate your database mission statement, you may want to start the text the following way:\n\nThe purpose of the name of organization and/or organizational unit database is…\n\nThis way you are less likely to forget that the database is what matters here.\nIdeally, your database mission statement would be aligned with the organization’s mission for which it is intended, so having a good understanding of the organization’s mission is essential. In real life, this part of the database design process would likely involve conducting interviews with the key actors of the organization and across its different departments to ensure that you have a good idea of the needs that your database will be addressing. However, in the context of this course, you will not be conducting interviews. You will have to use your best judgment to ensure that your database mission statement is related to the organization’s mission. Also, since organizations usually state their missions on their website, you can certainly use that information to help you.\nIt should also be noted that the database that you will be proposing, and its mission statement, do not necessarily have to cover everything that an organization does. You could, for instance, choose to develop a database that would support the teaching mission of a university without considering or mentioning the other missions of the university, such as research.\nOther constraints present in the context of the course, but not in real life, are the minimum number of specific tasks that your database should be supporting (5) and the minimum number of required tables in your database design (10). You can use these requirements to gauge whether your mission statement is too narrow or too broad.\n\n2.3.1.1 A database for GummyBox\nGummyBox is a new online store specializing in the sale and delivery of gummies and gummy assortments. The organization needs a database to support its operations. The company has multiple divisions with their own data needs. The HR department deals with employee records and data on pay and benefits, the purchasing department deals with orders to the suppliers, and the sales team handles customers’ orders. We decide to design a database that will support the operations of the sales department, and so we decide to name the database gummybox_sales and to formulate its mission as follows:\n\nThe purpose of the gummybox_sales database is to manage the data needed by the sales department to attend to the customers’ sweet tooth.\n\nWhile it may seem a bit vague at first glance, this statement aligns with the organization’s mission and the operations of the sales department. The statement will thus provide some guidance as we get further in the database design process.\n\n\n\n2.3.2 Database objectives statement\nThe database objectives are general tasks supported by the database. One way to distinguish them from the database mission is to remember that the mission statement relates to what the organization does. In contrast, the database objectives relate to the specific tasks or needs of people inside the organization (e.g., employees) or outside the organization (e.g., clients or users). Here are some examples:\n\nKeep track of students progress in their programs\nMaintain vehicle inventory\nManage song collections\nManage team roster\nKeep track of players performance\n\nHere is a list of criteria to help you write a good objective statement:\n\nIt represents a single task.\nIt is clear.\nIt does not contain unessential details.\nIt states what the task is, but does not indicate how it will be done by the database.\n\n\n2.3.2.1 Objectives for the gummybox_sales database\nIt was decided, after consultation with the GummyBox team, that their database will have the following objectives:\n\nMaintain customer information.\nKeep track of orders.\nMaintain information on gummies.\nMaintain information on gummy assortments.\nCollect product reviews."
  },
  {
    "objectID": "relational_databases_part1.html#subjects-and-attributes",
    "href": "relational_databases_part1.html#subjects-and-attributes",
    "title": "2  Relational databases (Pt. 1)",
    "section": "2.4 Subjects and attributes",
    "text": "2.4 Subjects and attributes\nNow that we have established the mission and objectives that the database will be supporting, we need to ask ourselves two questions:\n\nWhat entities (objects and events) are needed to fulfill the mission and objectives of the database? These objects and events constitute the subjects (or entities). If the mission is to support the activities of a job placement agency, your subjects would likely include jobs, job-seekers, employers, and agents. For a university, you might want to include things like students, courses, instructors, and departments.\nWhat attributes of the subjects are needed to fulfill the mission and objectives of the database? This is where you list, for each of the subjects identified with the first question, the attributes that your database requires. If one of the subjects of your database is customers, you would likely want to include their name, and possibly their email or phone number. But do you need their address? their social insurance number? the name of their first pet? There is no universal answer, so you need to ask yourself this question for every table in your database, and answer it based on your judgement and the mission and objectives of the database.\n\nRelational databases don’t impose rules on the subjects and attributes that you can include in your database. It does, however, impose rules on how these subjects and attributes must be captured in tables (subjects) and fields (attributes).\n\n2.4.0.1 Subjects and attributes of the gummybox_sales database\nIf the objectives of your database are well formulated, they may already provide you with all the subjects you need for your database. Here are the objectives of the gummybox_sales database in which I highlighted the subjects.\n\nMaintain customer information.\nKeep track of orders.\nMaintain information on gummies.\nMaintain information on gummy assortments.\nCollect procuct reviews.\n\nIdentifying subjects is no more complicated then that. I have five: customer, order, gummy, gummy assortments, and reviews.\n\n\n2.4.1 Database rules\nBefore we start building our database, it is important to identify or set rules that might constrain the values that an attribute can have for a single record or the relationships that can exist between two subjects.\nAn important question to ask when conceptualizing your database is whether a single instance of a subject (e.g., a specific customer, a specific gummy, or a specific order) can have multiple values for the same attribute. Consider, for instance, the customer subject of the gummybox_sales database. The attributes we identified are the customer’s name, email and address. We may want to consider whether or not a customer should be able to have multiple addresses. We can also consider whether the database should be able to attribute multiple colours of flavours to the same gummy. These decisions are database rules that we can make specify like this:\n\nAn individual customer can have more than one address.\nAn individual gummy can have multiple colours.\nAn individual gummy can have multiple flavours.\n\nWhen conceptualizing your database, it is also important to consider rules that apply to the relationship between subjects. For example, one of the subjects in the gummybox_sales database is reviews. There are several decisions to make about reviews that may have an impact on the database design. Some relevant questions might be:\n\nDo we accept reviews from everyone or do we only accept reviews from registered customers?\nCan both individual gummies and gummy assortments be reviewed?\nCan a customer provide a review for orders or only for products?\nCan a customer review the same product multiple times?\n\nThe answer to these questions establish the nature of the relationship between the reviews and other subjects in the database such as gummies, gummy assortments, customers and orders. They also help ensuring that all the necessary attributes have been included.\nWe can also set rules to limit the specific values that an attribute can have. These rules are often implied in the database mission and objectives. For instance, if you are building a database of Electronic music and artists, it implies that other genres will not be included in the database. In this, case you could simply not consider genre at all in the attributes of our tables, or include a genre attribute with a rule specifying that the genre must be electronic. In the gummybox_sales database, we could decide to specify the different types of flavours that a gummy can have: sweet, salty, sour, bitter and umami.\nNot all elements of your database needs explicit rules, but it is important to think about them early on to prevent headaches later in the process. It is also important to remember that the rules are decisions determined by the practices and needs of the organization and the database. They are not meant to reflect the absolute reality. For example, while it is a fact that a person can have multiple addresses in real-life, we are free to decide to allow only one address per customer in our database. Similarly, if we have a country attribute in our database, we are not obligated to consider the entire set of countries that exist in the world. We can limit the set of possible countries according to our needs. These choices can also sometimes be made out of convenience when certain rules increase the complexity of a database without clear benefits.\nImportant note: The most important rules to consider, especially for this course, are whether or not records can have multiple values for the same attribute (e.g. can a customer have more than one address?) and those that define relationship between subjects (e.g., are only customers allowed to post product reviews?). These rules have direct implications for your database design. On the other hand, while they can play a crucial role data validation and quality insurance purposes, value-limiting rules (e.g. the list of values that the country attribute can have) have little to no implications for your design. It is also easy to get carried away and start defining rules for all attributes that could contain a specific set of values, so you should avoid doing that and use these rules parsimoniously. Besides, they are not mandatory for the database design that you will produce in this course.\nFinally, you should also avoid setting explicit rules when the relationship between subjects of your database is obvious. For instance, it is obvious that customers can place multiple orders and that orders can contain multiple products. Only define the rules when there are multiple suitable options for your design."
  },
  {
    "objectID": "relational_databases_part1.html#summary",
    "href": "relational_databases_part1.html#summary",
    "title": "2  Relational databases (Pt. 1)",
    "section": "2.5 Summary",
    "text": "2.5 Summary\nThis chapter covered all the steps that deal with conceptual questions related to our database (i.e., those that are external to the requirements of the relational model) and you and your teammates should now be equipped to identify:\n\nThe mission and objective of your database.\nThe objects and events are included in the database\nThe attributes of these objects and events that will be included in the database\nThe rules that specify the number or set of values that an attribute can have for a single record, and the relationships that exists between subjects.\n\nIn the next chapter we will get one step closer to our fully operational database by converting that information into a set of tables, fields, and relationships that follow the rules of the relational model."
  },
  {
    "objectID": "relational_databases_part1.html#homework",
    "href": "relational_databases_part1.html#homework",
    "title": "2  Relational databases (Pt. 1)",
    "section": "2.6 Homework",
    "text": "2.6 Homework\nWith your teammates:\n\nDefine the mission and objectives of your database.\nDetermine the subjects and attributes that will be considered in your database.\nDefine the database rules that will specify whether .\n\nYou can (but are not required) to use this template.\nRemember that the decisions you make at this point are not set in stone and that you will be able to revisit them as you build your database, so don’t aim for perfection (yet)!"
  },
  {
    "objectID": "relational_databases_part3.html#learning-objectives",
    "href": "relational_databases_part3.html#learning-objectives",
    "title": "4  Relational databases (Pt. 3)",
    "section": "4.1 Learning objectives",
    "text": "4.1 Learning objectives\nConcepts\n\nData types\nConstraints\nIndices\nDocumentation\n\nPractical skills\n\nSet data types and constraints for your fields."
  },
  {
    "objectID": "relational_databases_part3.html#slides",
    "href": "relational_databases_part3.html#slides",
    "title": "4  Relational databases (Pt. 3)",
    "section": "Slides",
    "text": "Slides\n\n\nFull screen slides"
  },
  {
    "objectID": "relational_databases_part3.html#data-types",
    "href": "relational_databases_part3.html#data-types",
    "title": "4  Relational databases (Pt. 3)",
    "section": "4.2 Data types",
    "text": "4.2 Data types\nEvery field you include in a table needs to have a data type. The data type is extremely important as it determines how the RDBMS will interpret, store, and potentially transform the data inserted in the tables. The data type also determines the types of operations that can be performed with the data it contains.\nUnfortunately, the data types that are available to use for your database are also determined by the type of database that you are using. In this course, we will be implementing our database designs on a PostgreSQL database, which is one type of SQL (Structured Query Language) database, others being MySQL, SQLite, and Microsoft SQL Server. These databases can vary in what data types they can handle, but they do share basic data types such as numbers, text, and dates.\nIn this course, we will limit the data types used to three basic kinds: character, numeric, and dates and times.\n\n4.2.1 Character data types\nCharacter data types are very flexible because they can contain any combination of letters, numbers or symbols. The most common data types are character(n) or char(n) and character varying(n) or varchar(n). The n sets the maximum number of characters that the field can contain. For example, a field with the data type varchar(5) will not be able to store strings longer than 5 characters (such as the word “banana”). The term varying indicates that the field is expected to contain strings of different length. You should use the character(n) data type only when the length of the strings you will store will not vary (ex., country codes, phone numbers, postal codes), and the character varying data type should be used when the length of the strings is expected to vary. PostgreSQL also has the text datatype which is essentially the same as character varying with no limit specification.\nMore information on the string data types can be found in the PostgreSQL documentation.\n\n\n\n\n\n\nShould you specify a maximum length for your character fields?\n\n\n\nLet’s say you are storing names of individuals in one of your database fields. You may be tempted to choose text of character varying without specifying a character limit, since you don’t know the length of the longest name that this field could ever store. However, there is in fact a limit of PostgresSQL 10,485,760 characters (which is about 1GB), which means that without any other mechanisms to restrict the length of the string might open up the door to pranks, attacks, or errors where one would enter a very long string in the field, and blow up the storage requirement of your database. It is therefore recommended to set a limit to your character fields in all cases, but to make sure that the limit is large enough to accommodate all plausible values for the field.\n\n\n\n\n4.2.2 Numeric data types\nThe numeric data types store… you guessed it: numbers! The main numeric data types available in PostgreSQL are listed in the table below.\n\n\n\n\n\n\n\n\n\nName\nStorage Size\nDescription\nRange\n\n\n\n\nsmallint\n2 bytes\nsmall-range integer\n-32768 to +32767\n\n\ninteger\n4 bytes\ntypical choice for integer\n-2147483648 to +2147483647\n\n\nbigint\n8 bytes\nlarge-range integer\n-9223372036854775808 to +9223372036854775807\n\n\ndecimal\nvariable\nuser-specified precision, exact\nup to 131072 digits before the decimal point; up to 16383 digits after the decimal point\n\n\nnumeric\nvariable\nuser-specified precision, exact\nup to 131072 digits before the decimal point; up to 16383 digits after the decimal point\n\n\nreal\n4 bytes\nvariable-precision, inexact\n6 decimal digits precision\n\n\ndouble precision\n8 bytes\nvariable-precision, inexact\n15 decimal digits precision\n\n\nsmallserial\n2 bytes\nsmall autoincrementing integer\n1 to 32767\n\n\nserial\n4 bytes\nautoincrementing integer\n1 to 2147483647\n\n\nbigserial\n8 bytes\nlarge autoincrementing integer\n1 to 9223372036854775807\n\n\n\nThere are two basic types of numbers: integers (no decimals), and floating-point numbers (allow decimals).\nFor integers, the main decision you have to make is the storage size. To minimize costs and optimize performance, it is generally best to choose the smallest possible type that will be able to store all plausible values for the field.\nSerials are integers that auto-increment, which means that no values need to be inserted in this field when a new entry is created in the table. This is often used for automatically generating unique primary keys.\nFor values with decimals, I recommend using the numeric data allows you to fix the number of total digits, and the number of decimals values can have. For instance, the numeric(5,2) data type indicates that the field can contain values with 5 digits and 2 decimals so the range would be -999.99 to 999.99. This is particularly useful for financial data or other cases where having more than a certain number of decimals makes no sense (e.g., 2.333$). If you do not want to fix the precision and scale of your numeric field, you can use the data type numeric without the parentheses, which will store data with any number of digits before and after the decimal points\nMore information on the numeric data types can be found in the PostgreSQL documentation.\n\n\n4.2.3 Date and time\nThe different date and time data types that you can use in MySQL are presented in the following table.\n\nsource: https://www.postgresql.org/docs/current/datatype-datetime.html\n\n\nName\nStorage Size\nDescription\nLow Value\nHigh Value\nResolution\n\n\n\n\ntimestamp without time zone\n8 bytes\nboth date and time (no time zone)\n4713 BC\n294276 AD\n1 microsecond\n\n\ntimestamp with time zone\n8 bytes\nboth date and time, with time zone\n4713 BC\n294276 AD\n1 microsecond\n\n\ndate\n4 bytes\ndate (no time of day)\n4713 BC\n5874897 AD\n1 day\n\n\ntime without time zone\n8 bytes\ntime of day (no date)\n00:00:00\n24:00:00\n1 microsecond\n\n\ntime with time zone\n12 bytes\ntime of day (no date), with time zone\n00:00:00+1559\n24:00:00-1559\n1 microsecond\n\n\n\nMore details on the date and time formats can be found in the PostgreSQL documentation.\n\n\n\n\n\n\nImportant note\n\n\n\nPostgreSQL supports a lot more data types (and structures) than those presented above, and the supported data types also vary for different RDBMS, but these systems are constantly evolving and expanding the data types they can handle. But the types presented here should be more than enough for most use cases, and in the context of this class."
  },
  {
    "objectID": "relational_databases_part3.html#constraints",
    "href": "relational_databases_part3.html#constraints",
    "title": "4  Relational databases (Pt. 3)",
    "section": "4.3 Constraints",
    "text": "4.3 Constraints\nSQL constraints are used to specify rules for data in a table. They are used to preserve the integrity of the database, ensure data quality, and prevent data loss. While you do not need to use constraints other than the primary key and the foreign key ones for this course, it is helpful to know about constraints and what they do. Here is a list of constraints that are available in PostgreSQL.\n\nPrimary key: As you already know, the primary key must be unique and cannot be empty. The RDBMS also automatically creates an index (explained below) on this field.\nNot null: Specifies that this field must always contain a value and cannot be empty (null).\nUnique: A field with a unique constraint cannot contain duplicate values.\nForeign key: the value inserted into a foreign key must exist in the primary key field of the parent table. Null values are allowed in foreign key fields.\nCheck: the check constraint is a very flexible constraint that allows you to specify the specific values that a field can contain. For example, you could set a check constraint on the number of gummies in an order specifying that the value must be greater than 0.\nDefault: This constraint defines a default value to be inserted in the field when a new record is created, and no value is provided for that specific field."
  },
  {
    "objectID": "relational_databases_part3.html#documenting-your-database",
    "href": "relational_databases_part3.html#documenting-your-database",
    "title": "4  Relational databases (Pt. 3)",
    "section": "4.5 Documenting your database",
    "text": "4.5 Documenting your database\nNow that you have a complete database designed, with tables, fields with all the appropriate data types and constraints. You are ready to move to the next step: documentation.\nAdequately documenting your database is crucial because it ensures that the users will be able to understand what tables contain, why they exist, and how to use your database. You already know (and have applied) best practices for table and field names. That likely reduces the need for your database users to refer to the documentation all the time, but it does not eliminate the need for it. Describing your tables and fields also helps ensure they are needed and well-designed. If you cannot describe the purpose of a table, it may be that it has, in fact, no purpose.\nHere are a few simple rules to follow:\n\nClearly and concisely describe the tables and fields.\nFor tables only, your description should provide some indication of its purpose (why it is necessary).\nFocus on the content of the tables or fields rather than how they will specifically be used or accessed and by whom.\nDo not use examples in your descriptions."
  },
  {
    "objectID": "relational_databases_part3.html#exercises",
    "href": "relational_databases_part3.html#exercises",
    "title": "4  Relational databases (Pt. 3)",
    "section": "4.5 Exercises",
    "text": "4.5 Exercises\nAs an exercise for this week, I invite you to connect to your team’s database on the qsslab MySQL server (using the connection information that you received by email) and to experiment with data types and constraints by creating your tables, inserting data into those tables, and then retrieving the content of the tables to see how your data was stored. Because you cannot break the database and the worst thing that can happen is that your queries return an error, don’t be afraid to try crazy queries that you know should not work (for instance, storing the string “abcd” in a DATETIME field), just to see how SQL reacts. That said, please limit your queries to CREATE, INSERT, SELECT and DROP statements at this point."
  },
  {
    "objectID": "relational_databases_part2.html#learning-objectives",
    "href": "relational_databases_part2.html#learning-objectives",
    "title": "3  Relational databases (Pt. 2)",
    "section": "3.1 Learning objectives",
    "text": "3.1 Learning objectives\nConcepts\n\nTable and fields\nTable types\nRelationship types\nEntity-Relationship Diagrams\n\nPractical skills\n\nCreate an Entity-Relationship Diagram (team assignment #2)\nOptimize the structure of your database (team assignment #2)"
  },
  {
    "objectID": "relational_databases_part2.html#introduction",
    "href": "relational_databases_part2.html#introduction",
    "title": "3  Relational databases (Pt. 2)",
    "section": "3.2 Introduction",
    "text": "3.2 Introduction\nUntil now, we have been thinking about database and its subjects, attributes and rules without considering their implementation in an actual relational database and the additional rules that relational databases impose on our design. In this chapter, we will begin to transform our database subjects, attributes and rules into a database model with tables, fields and relationships."
  },
  {
    "objectID": "relational_databases_part2.html#tables-and-fields",
    "href": "relational_databases_part2.html#tables-and-fields",
    "title": "3  Relational databases (Pt. 2)",
    "section": "3.3 Tables and fields",
    "text": "3.3 Tables and fields\nWe already know from the short introduction to relational databases in the previous chapter that our subjects are represented as tables and their attributes as fields (columns) in those tables. However, because of the rules of relational database design, converting subjects to tables and attributes to fields is not simply a matter of changing the labels in the design.\nHere are the two most important rules to follow when creating tables:\n\nEach table represents a single subject. Gummies and their attributes are stored in one table, orders in another, customers in another, and so on. The set of fields in a table defines the subject, and it would make no sense for a subject to be defined by a gummy name, description, flavour, price as well as by a customer name, a delivery address and a phone number. When adding fields to a table, it is important to ask whether the fields are defining characteristics of the subject represented. Some associative tables (we explain what those are below) can be created for the specific purpose of capturing the relationship between two other tables or accommodate the possibility for an attribute to have multiple values for the same record. Such tables are exceptions as their function is not to represent subjects.\nEach table has at least one field that will be the primary key. The primary key is a unique identifier for each record stored in the table (the same primary key cannot appear twice in the table). The primary key is also used to reference a record from one table in another table. The field that makes the reference is called a foreign key. For instance, in the gummybox_sales database, customers will be represented in a customer table that contains a primary key named id. Records in another table (e.g., the order table) might need to indicate which customer placed the order. Rather than repeating all the customer information in the order table, each record instead simply needs to includes the id of the customer. In the order table we would then have a field named customer_id that would be a foreign key (i.e., the primary key of another table).\n\nThere are also several important principles that fields should follow:\n\nEach field should be unique in the entire database (except foreign keys). You should avoid repeating the same fields in different tables. For instance, if country is an attribute of more than one subject in your database, you should consider using a validation table (we explain what those are below) called country and include in your other tables a foreign key referencing the country table.\nEach field represents a distinct attribute of the subject. A field should not combine, for example, the birth date and the age, the height and weight and any other attributes of the subject. Each attribute has its field.\nEach field contains a single value that cannot be deconstructed into smaller ones. The name of a person is an example of a field that can be deconstructed into smaller ones (e.g., first name and last name).\nFields should not contain calculated values. For instance, we could be tempted to include the total price for an order in an order table. However, this would most likely not be optimal if the total price of an order can be calculated by multiplying the number of units included in the order by their individual price.\n\n\n3.3.1 Naming tables and fields\nHernandez (2013) proposes some guidelines for naming your tables and fields to make your database easier to understand and navigate. The table below includes all of Hernandez’s recommendations.\nCharacteristics of a good table and field names\n\n\n\n\n\n\n\n\nRule\nBad\nGood\n\n\n\n\nAccurate, unique, and meaningful to the organization\nTableA\nOrders\n\n\nRefers to a single subject (unless it is an associative table)\nFaculties/Departments\nMake two tables\n\n\nAs short as possible\nCoursesOffered\nCourses\n\n\nDo not use words like list, records, data\nCoursesList\nCourses\n\n\nDoes not use acronyms\nSRIs\nStudent_Ratings_of_Instruction\n\n\nDoes not unduly restrict the data that can be entered into the table\nFall_courses\nCourses\n\n\n\n\n\n3.3.2 Table types\nThere are three basic table types that you will encounter in your database:\n\nData tables typically represent the main subjects of your database (e.g., objects, people, events). They usually have a single primary key, and they gather data that provides information about the subject represented in the table.\nAssociative tables create associations between the subjects in your database (e.g., students-courses, products-orders, customers-orders). They have typically had multiple foreign keys that together will form the composite primary key. Some, but not all, of the main subjects of a database design can be associative tables.\nValidation tables (look-up tables) are used for data quality and validation purposes. They contain the list of possible values that a field can take. For instance, your grade for this class has a limited set of possible values (A+, A, A-, B+, B, B-, F, AUD, ILL, INC, IP, P). A validation table can but does not have to be used to store these possible values to ensure that a user cannot enter the grade “G” or “Banana” in the grade field of the database. Validation tables are also useful for reducing the memory requirement of your database. You can replace large data types, such as character strings, with smaller data types, such as numbers. We will learn more about data types in the next chapter."
  },
  {
    "objectID": "relational_databases_part2.html#relationship-types",
    "href": "relational_databases_part2.html#relationship-types",
    "title": "3  Relational databases (Pt. 2)",
    "section": "3.4 Relationship types",
    "text": "3.4 Relationship types\nRelationships are critical determinants of the structure of your database. They are represented by foreign keys in some of your tables linked to other tables’ primary keys. Luckily, relationships are a relatively simple concept that is easy to implement in your database design process. There are only three basic kinds of relationships, so let’s take a quick look at them.\n\n3.4.1 One-to-one relationship\nThis relationship exists when one record in a table can only be associated with one record in another table and vice versa. A one-to-one relationship may exist, for instance, between the office space and the personnel of an organization, as long as nobody is allowed to share an office or to have two offices. These relationships are rare in reality since it often makes more sense to bring back to combine tables with one-to-one relationships in a unique table. However, there are situations where the use of one-to-one relationships can be required or appropriate, for example:\n\nSecurity: you may want to store sensitive information about an individual in a different table that only some authorized users can access.\nSemantics: even though you could include information about the office space in your employees table, you might not want to store information about your offices with your employees table. First names, last names and birth dates are characteristics of people, but buildings and room numbers are not.\n\n\n\n3.4.2 One-to-many relationship\nA one-to-many relationship exists when one record in a table can be associated with one or more records in another table. It is the most frequent type of relationship in properly designed databases. A typical example is the customers table and the orders table. A single customer record can be associated with multiple orders, but only one customer can be associated with a specific order.\n\n\n3.4.3 Many-to-many relationship\nMany-to-many relationships exist when one record in a table can be associated with multiple records in another table and vice versa. A typical example is a product that can be part of multiple orders and an order that can contain multiple products. Another example is the relationship between university courses and students. A single course can have multiple students. Inversely, a single student can be enrolled in multiple courses.\n\n3.4.3.1 Issues with many-to-many relationships\nThese relationships are widespread in the world, and they are great. However, they also raise potential issues that need to be resolved in your database design. By definition, these relationships imply that the non-duplication of the primary key rule will be violated so that something that your RDBMS will not allow.\n\nOne solution for that is to use a composite primary key. This means your table has two or more primary keys instead of one. In practice, that means that every combination of the two fields forming the key are not allowed to be repeated in the table.\n\nHowever, the composite key solution is often not optimal since it can create a lot of redundancy in your table, which you want to minimize as much as possible.\n\nThat is the purpose of associative tables. They are tables created with the specific purpose of linking your subjects together to prevent primary key duplication and minimize redundancy.\n\nNow the Melvil Dewey information is not repeated in the database for every course they are registered for. In fact, none of the information is repeated other than the primary and foreign keys."
  },
  {
    "objectID": "relational_databases_part2.html#entity-relationship-diagrams",
    "href": "relational_databases_part2.html#entity-relationship-diagrams",
    "title": "3  Relational databases (Pt. 2)",
    "section": "3.5 Entity-relationship diagrams",
    "text": "3.5 Entity-relationship diagrams\nAn entity-relationship diagram (ERD) is a visual representation of your database that typically includes every table along with their fields and the relationship between them. The ERD is a helpful tool for designing your database because it helps you visualize your table and fields and their relationship, making it easier to spot mistakes and inconsistencies. It is also a valuable part of your database documentation as it can give users a good understanding of the data to use it more effectively. The video below demonstrates how to draw ERDs using diagrams.net (formerly draw.io).\n\n\n\n\n\n\nImportant\n\n\n\nYou should watch the video even if you already know how to use diagrams.net or are not planning to use it for the course. It provides general guidance on ERD and database design.\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nWhen you are at the very early stages of your design and still very unclear about what your tables may look like, it can be a good idea to try things out on a whiteboard (or paper) to get a quick sense of what works and what doesn’t."
  },
  {
    "objectID": "relational_databases_part2.html#homework",
    "href": "relational_databases_part2.html#homework",
    "title": "3  Relational databases (Pt. 2)",
    "section": "3.6 Homework",
    "text": "3.6 Homework\nThe homework for this week is to start designing your database with your teammates and working on individual lab #2.\n\n\n\n\nHernandez, Michael J. 2013. Database Design for Mere Mortals: A Hands-on Guide to Relational Database Design. Third edition. Upper Saddle River, NJ: Addison-Wesley."
  },
  {
    "objectID": "relational_databases_part2.html#appendix-a---installing-mysql-workbench",
    "href": "relational_databases_part2.html#appendix-a---installing-mysql-workbench",
    "title": "3  Relational databases (Pt. 2)",
    "section": "3.7 Appendix A - Installing MySQL Workbench",
    "text": "3.7 Appendix A - Installing MySQL Workbench\nImportant: while the latest version of MySQL Workbench (8.0.28) will work to design your database model. It is not supported by the MySQL server that you can use to go live with your database, add data to it, and write SQL queries to retrieve it. Using the live server is not required in the course but strongly recommended, so you should install MySQL Workbench 8.0.27 or an earlier version.\nTo install MySQL Workbench on your computer, go to https://dev.mysql.com/downloads/workbench/\nThen choose archives to access previous versions.\n\n\nYou will be asked if you want to sign up for an Oracle web account. You do not need to sign up. Simply click on “No thanks, just start my download” (as show in the image below)."
  },
  {
    "objectID": "relational_databases_part2.html#appendix-b---the-gummybox_sales-erd",
    "href": "relational_databases_part2.html#appendix-b---the-gummybox_sales-erd",
    "title": "3  Relational databases (Pt. 2)",
    "section": "3.8 Appendix B - The gummybox_sales ERD",
    "text": "3.8 Appendix B - The gummybox_sales ERD\n\n\n\n\n\nHernandez, Michael J. 2013. Database Design for Mere Mortals: A Hands-on Guide to Relational Database Design. Third edition. Upper Saddle River, NJ: Addison-Wesley."
  },
  {
    "objectID": "relational_databases_part2.html#appendix-a---installing-pgadmin",
    "href": "relational_databases_part2.html#appendix-a---installing-pgadmin",
    "title": "3  Relational databases (Pt. 2)",
    "section": "3.7 Appendix A - Installing pgAdmin",
    "text": "3.7 Appendix A - Installing pgAdmin\nTo install pgAdmin on your computer, go to https://dev.mysql.com/downloads/workbench/"
  },
  {
    "objectID": "relational_databases_part2.html#section",
    "href": "relational_databases_part2.html#section",
    "title": "3  Relational databases (Pt. 2)",
    "section": "3.7 ",
    "text": "3.7 \n\n\n\n\nHernandez, Michael J. 2013. Database Design for Mere Mortals: A Hands-on Guide to Relational Database Design. Third edition. Upper Saddle River, NJ: Addison-Wesley."
  },
  {
    "objectID": "relational_databases_part3.html#indices",
    "href": "relational_databases_part3.html#indices",
    "title": "4  Relational databases (Pt. 3)",
    "section": "4.4 Indices",
    "text": "4.4 Indices\nCreating an index for the values of a field can dramatically increase the speed of your queries. Just like an index at the end of a book telling you on what page(s) you can find information about a particular concept or topic instead of having to look at each page to find those sections, the index creates a list of records where each of the different values of that field can be found and stores that list into its memory, so that those records can be retrieved much faster. So, for example, if you have 50 different gummy records in your gummy table, 12 of which are red, 25 are blue, and 13 are green, you could create an index on the gummy_color table. The index would have one record for each colour (red., blue, green), each containing a list of the gummy_id that has that colour.\nFor example, if you ask the database to retrieve the blue gummies from the gummy table and you do not have an inde on the colour column, it has to scan each row, to see the colour is “blue”, if the table as 1 million rows, then this verification has to be done 1 million times.\nNo index on the colour field of the gummy table\n\nWith an index on the colour field of the gummy table\nIf you ask the database to retrieve the blue gummies from the gummy table, and have an index on the colour column. The database scans the index until it finds the colour “blue” and and then fetches the rows of the gummy table with that are blue. If there are 50 possible colours, then the database has to scan between 1 and 50 rows (depending when it finds the value “blue”)."
  },
  {
    "objectID": "rdbms.html#learning-objectives",
    "href": "rdbms.html#learning-objectives",
    "title": "5  Relational database management systems",
    "section": "5.1 Learning objectives",
    "text": "5.1 Learning objectives\nIn this hands-on chapter, you will learn how to connect to a PostgreSQL database hosted in the cloud and implement your database design by creating tables and populating them with data."
  },
  {
    "objectID": "rdbms.html#what-is-an-rdbms",
    "href": "rdbms.html#what-is-an-rdbms",
    "title": "5  Relational database management systems",
    "section": "5.2 What is an RDBMS?",
    "text": "5.2 What is an RDBMS?\nAs we saw in the first chapter of this book. Database Management Systems (DBMS) are software that supports the development, maintenance, security, and use of databases. The R in RDBMS stands for relational, and it is the kind of DBMS that we will be using to implement and manage the relational databases that we have been developing. PostgreSQL is an increasingly popular RDBMS that can also handle non-relational data structures. It does not have an interface; it is the engine that stores your data and enforces rules regarding the content of your fields and tables, who can access them, etc."
  },
  {
    "objectID": "rdbms.html#psql-and-pgadmin",
    "href": "rdbms.html#psql-and-pgadmin",
    "title": "5  Relational database management systems",
    "section": "5.3 psql and pgAdmin",
    "text": "5.3 psql and pgAdmin\npsql is a command-line interface that allows you to manage and interact with PostgreSQL using commands and SQL code. You can essentially do everything you need to do in psql, including creating databases, users, tables, importing and exporting data, etc. However, the command-line interface is not very pleasing to the eye, and while database administrators and geeky coders might insist that it is better than using a graphical user interface (GUI) that allows you to perform operations by clicking buttons and filling structured forms, for this course, we will use such a free and open-source GUI called pgAdmin. You will notice that every operation you perform in pgAdmin is actually translated into SQL code, and it is that code which is executed and produces the outcome. This code is often displayed in pgAdmin and that can be a useful way to learn how to learn the SQL language.\nYou can install PostgreSQL on your computer and use pgAdmin to manage local databases. However, for this course, we will use a PostgreSQL database hosted on a Microsoft Azure server. The next sections walk you through the process of installing pgAdmin, connecting to the course database, creating tables on the schema created for your team, and adding data to your tables. By the end of this process, you will have a live database that can fulfill its intended purpose."
  },
  {
    "objectID": "rdbms.html#installing-pgadmin",
    "href": "rdbms.html#installing-pgadmin",
    "title": "5  Relational database management systems",
    "section": "5.4 Installing pgAdmin",
    "text": "5.4 Installing pgAdmin\n\n5.4.1 Go to the pgAdmin website and click on the download tab.\n\n\n\n\n\n\n\n5.4.2 Choose your operating system\n\n\n\n\n\n\n\n5.4.3 Select the latest version of the software\n\n\n\n\n\n\n\n5.4.4 Download the installation file\n\n\n\n\n\nAt this point, you should just follow the instructions and install the software without changing any of the default settings. Note that when you open pgAdmin for the first time, you will be asked for a master password. Choose something you will remember."
  },
  {
    "objectID": "rdbms.html#connecting-to-the-server",
    "href": "rdbms.html#connecting-to-the-server",
    "title": "5  Relational database management systems",
    "section": "5.5 Connecting to the server",
    "text": "5.5 Connecting to the server\nThe first thing you’ll want to do in pgAdmin is adding a connection to the info6540 server.\n\n\n\n\n\n\n5.5.1 Set a name for the server connection\n\n\n\n\n\n\n\n5.5.2 Enter the login details provided to you by email\n\n\n\n\n\nYou can now see the server connection on the left panel, and access it there."
  },
  {
    "objectID": "rdbms.html#creating-tables",
    "href": "rdbms.html#creating-tables",
    "title": "5  Relational database management systems",
    "section": "5.6 Creating tables",
    "text": "5.6 Creating tables\n\n5.6.1 locate your team’s schema\nYou will notice two schemas with your team name: one is just the team name, and the other has _sandbox at the end. The _sandbox schema is there for you to play around and try stuff out as you please. So, feel free to experiment there if you want to try something new and are afraid of messing up your main database.\n\n\n\n\n\n\n\n5.6.2 Create tables\nTo create a table, click on the schema you want to create a table in, find the tables icon, right-click on it, and select Create, then Table…\n\n\n\n\n\n\n\n5.6.3 Give your table a name\n\n\n\n\n\n\n\n5.6.4 Define your table columns\n\n\n\n\n\n\n\n5.6.5 Set foreign key constraints\nBecause you cannot add a foreign key constraint pointing to the id of a table that does not yet exist. You should create your validation (look-up) tables first, then create your data tables, and create you associative tables last. Here’s how you set the foreign keys, in the constraints tab of the create table process. If your table is already created, you can add the foreign key constraints in the by right-clicking the table and selecting properties… Here are a few screenshots that show what the process of adding a foreign key looks like:"
  },
  {
    "objectID": "rdbms.html#adding-data-to-tables",
    "href": "rdbms.html#adding-data-to-tables",
    "title": "5  Relational database management systems",
    "section": "5.7 Adding data to tables",
    "text": "5.7 Adding data to tables\nNow that we have learned how to create tables in PostgreSQL using pgAdmin, we are ready to populate these tables with data. One important thing to remember when populating your tables is that the order in which we populate the tables is important. Just like a table cannot reference another table that does not yet exist, so is a foreign key column not allowed to contain a value that does not exist in the referenced column. In practice, this means that a product that does not exist cannot be part of an order, and a customer that does not exist cannot have an address in the database, which is pretty logical, and also prevents errors in the data. So, the order for data entry is the same as for table creation: validation tables first, then data tables, then associative tables.\nThe next two sections show how to populate tables manually or by reading the data from a file.\n\n5.7.1 Manually\nYou can add data manually by viewing it and then manually filling or updating the cells.\n\n\n\n\n\n\n\n\n\n\n\n\n5.7.2 Using the import/export tool\nAdding data to cells one by one in pgAdmin can be a little time-consuming. You may wish to create CSV files with the data and then import this data to your tables with the import/export tool.\n\n\n\n\n\n\n\n5.7.3 Locate the file to import on your computer\n\n\n\n\n\n\n\n5.7.4 Set the appropriate options\n\n\n\n\n\n\n\n5.7.5 Choose columns to be imported\n\n\n\n\n\nOnce the process is completed, we can verify that the data was imported properly by right-clicking on the table name and then selecting View/Edit Data."
  },
  {
    "objectID": "rdbms.html#conclusion",
    "href": "rdbms.html#conclusion",
    "title": "5  Relational database management systems",
    "section": "5.8 Conclusion",
    "text": "5.8 Conclusion\nThat’s it! Now you know how to implement database designs on a real server and populate your tables with data. In the next week, you will learn the basics of the SQL language and how to write SQL queries to extract data from your database and produce database views that fulfill some needs for some users of the databases."
  },
  {
    "objectID": "rdbms.html#section",
    "href": "rdbms.html#section",
    "title": "5  Relational database management systems",
    "section": "5.9 ",
    "text": "5.9"
  },
  {
    "objectID": "sql.html#learning-objectives",
    "href": "sql.html#learning-objectives",
    "title": "6  Structured Query Language (SQL)",
    "section": "6.1 Learning objectives",
    "text": "6.1 Learning objectives\nConcepts\n\nStructured Query Language (SQL)\nDatabase views\n\nPractical skills\n\nWriting SQL queries to extract data from a database (Lab #3)\nCreating database views in a RDBMS (team assignment #3)"
  },
  {
    "objectID": "sql.html#what-is-sql",
    "href": "sql.html#what-is-sql",
    "title": "6  Structured Query Language (SQL)",
    "section": "6.2 What is SQL?",
    "text": "6.2 What is SQL?\nSQL is a language with a relatively simple and intuitive syntax that uses written statements (or queries) to interact with the RDBMS to perform various operations such as creating databases, tables and other objects, inserting or updating data in tables and, of course, retrieve data."
  },
  {
    "objectID": "sql.html#syntax",
    "href": "sql.html#syntax",
    "title": "6  Structured Query Language (SQL)",
    "section": "6.3 Syntax",
    "text": "6.3 Syntax\nA SQL statement typically looks like this.\n\nSELECT [TableName].[FieldName] \nFROM [DatabaseName].[TableName];\nJOIN [DatabaseName].[TableName] ON [Condition]\nWHERE [Condition]\nGROUP BY [list of fields that form groups]\nORDER BY [field(s) to use for ordering, either ascending (ASC) or descending (DESC)];\n\nIn English, the statement SELECTs some data FROM some table JOINed with some other table ON some condition, and WHERE the final joined tables meet some other condition. The aggregated values (if used) are GROUPed BY the other fields selected. Finally, the results are ORDERed BY one of the field values in ASCending or DESCending order.\nHere’s an example of an n actual SQL statement, which cacluates the average price of gummies with different consistencies, and order the resuls from highest average price to lowest.\n\nSELECT gummies.consistency, price_denominators.denominator, avg(gummies.price)\nFROM gummybox_sales.gummies\nJOIN gummybox_sales.price_denominators ON gummybox_sales.price_denominators.id = gummybox_sales.gummies.price_denominator_id\nWHERE gummies.colour = 'blue'\nGROUP BY gummies.consistency, price_denominators.denominator\nORDER BY avg(gummies.price) DESC;\n\n\n4 records\n\n\nconsistency\ndenominator\navg\n\n\n\n\nhard\nper unit\n0.50\n\n\nsoft\nper unit\n0.25\n\n\nsoft\nper gram\n0.05\n\n\nchewy\nper unit\n0.03\n\n\n\n\n\nNot all of these parts are necessary for all statements. What you need to include depends on what you are trying to achieve. However, you will rarely have any other components than these in your statements. You can write your statements on a single line or spread them on multiple lines like I do. However, you must always respect the order of the elements. Your statement will not work if you put the GROUP BY part before the WHERE part, for instance. Also, try to remember to end your statements with a semi-colon.\nFinally, keep in mind that the default setting for PostgreSQL is case sensitivity, so “banana”, “BANANA”, and “BaNaNa” are not the same. However, this does not apply to the name of tables, functions, and operators. For my examples, I capitalize the functions and operators so that they can be more easily distinguished from the other elements of the statements, but in your SQL statements, select or SELECT would be interpreted the same way and .\nIn the next section, I provide examples of the different functions and operators that you may need to use in your statements. These are far from exhaustive, but should cover 95% of the basic queries that users make when working with relational databases. Administrators of databases will typically use much more functions, but that is beyond the scope of this course."
  },
  {
    "objectID": "sql.html#the-gummybox_sales-erd",
    "href": "sql.html#the-gummybox_sales-erd",
    "title": "6  Structured Query Language (SQL)",
    "section": "6.4 The gummybox_sales ERD",
    "text": "6.4 The gummybox_sales ERD"
  },
  {
    "objectID": "sql.html#retrieve-data",
    "href": "sql.html#retrieve-data",
    "title": "6  Structured Query Language (SQL)",
    "section": "6.5 Retrieve data",
    "text": "6.5 Retrieve data\n\n6.5.1 SELECT\nyou can use select to retrieve data from a table.\n\n6.5.1.1 Select an entire table\nTo retrieve all the data in a table with SELECT * FROM [table].\n\nSELECT *\nFROM gummybox_sales.gummies\n\n\nDisplaying records 1 - 10\n\n\n\n\n\n\n\n\n\n\n\n\n\nid\nname\ndescription\nconsistency\ncolour\nflavour\nflavour_type_id\nprice\nprice_denominator_id\n\n\n\n\n1\nBada Booms\nAn explosion of taste\nsoft\nblue\nstrawberry\n1\n0.05\n1\n\n\n2\nVinson Drops\nSoup. Now in gummy form\nchewy\nbrown\nsoup\n2\n0.20\n2\n\n\n3\nSalmoniakki\nSalmon flavored salted licquorice\nhard\nblack\nsalmon liquorice\n2\n0.50\n2\n\n\n4\nFroggurt\nFrog meat flavored yogurt gummy\nsoft\ngreen\nfrog\n1\n0.50\n2\n\n\n5\nGarum Gummae\nA gummy take on a Roman flavor\nstretchy\nblack\nanchovie\n3\n1.00\n2\n\n\n6\nApple Bottom Jeans\nGummies shaped like jeans with apple flavor\nchewy\nblue\napple\n1\n0.03\n2\n\n\n7\nDog Residue\nImitates dog dropping with imitation dog dropping flavor\nhard\nbrown\ndog\n4\n0.01\n2\n\n\n8\nKitty Litter\nEver wanted to eat the drop box?\nhard\nwhite\nammonia\n4\n0.01\n2\n\n\n9\nFrostbite\nImitates how it feels to have frostbite\nhard\nblue\nminty\n5\n0.50\n2\n\n\n10\nMatchsticks\nGood for eating; not to ignite\nhard\nred\nphosphorus\n3\n0.80\n2\n\n\n\n\n\n\n\n6.5.1.2 Select specific fields from a table\nWhen you only want to retrieve a few fields from a table, you need to specify the names fo the fields. In the example above, I retrieve information about gummies, excluding a few field like their id, and their price.\nNote : when listing fields, the table name is only required when the same field name is ambiguous because it exists in more than one table included in your query.\n\nSELECT \n  gummies.name, \n  gummies.description, \n  gummies.consistency, \n  gummies.colour\nFROM gummies; \n\n\nDisplaying records 1 - 10\n\n\n\n\n\n\n\n\nname\ndescription\nconsistency\ncolour\n\n\n\n\nBada Booms\nAn explosion of taste\nsoft\nblue\n\n\nVinson Drops\nSoup. Now in gummy form\nchewy\nbrown\n\n\nSalmoniakki\nSalmon flavored salted licquorice\nhard\nblack\n\n\nFroggurt\nFrog meat flavored yogurt gummy\nsoft\ngreen\n\n\nGarum Gummae\nA gummy take on a Roman flavor\nstretchy\nblack\n\n\nApple Bottom Jeans\nGummies shaped like jeans with apple flavor\nchewy\nblue\n\n\nDog Residue\nImitates dog dropping with imitation dog dropping flavor\nhard\nbrown\n\n\nKitty Litter\nEver wanted to eat the drop box?\nhard\nwhite\n\n\nFrostbite\nImitates how it feels to have frostbite\nhard\nblue\n\n\nMatchsticks\nGood for eating; not to ignite\nhard\nred\n\n\n\n\n\n\n\n6.5.1.3 Print values that are not in a table\n\nSELECT 'Banana'\n\n\n1 records\n\n\n?column?\n\n\n\n\nBanana\n\n\n\n\n\nNotice that the name of the returned column in this case is ?column?… we will learn how to rename columns with aliases (AS function) later on.\n\n\n\n6.5.2 SELECT DISTINCT\nThe SELECT DISTINCT statement eliminate duplicate rows from the returned table. So if we want to retrieve a list of the gummy consistencies available, we would not want “hard” to be repeated in the list for every hard gummy available. We can do that with a SELECT DISTINCT statement.\n\nSELECT DISTINCT gummies.consistency \nFROM gummies; \n\n\n4 records\n\n\nconsistency\n\n\n\n\nhard\n\n\nsoft\n\n\nstretchy\n\n\nchewy\n\n\n\n\n\n\n\n6.5.3 WHERE\nPerhaps you do not want to retrieve all the records of a table, but only a subset that meets a certain condition. Let’s try, for instance, to retrieve all the gummies that are blue from gummy table.\n\nSELECT \n  gummies.name, \n  gummies.description, \n  gummies.colour \nFROM gummies\nWHERE gummies.colour = 'blue'; \n\n\n4 records\n\n\n\n\n\n\n\nname\ndescription\ncolour\n\n\n\n\nBada Booms\nAn explosion of taste\nblue\n\n\nApple Bottom Jeans\nGummies shaped like jeans with apple flavor\nblue\n\n\nFrostbite\nImitates how it feels to have frostbite\nblue\n\n\ngummyX\nStrangeness\nblue\n\n\n\n\n\n\n\n6.5.4 ORDER BY\nThe order by function lets you choose the order in which you would like the data to be displayed. Here we order the gummies in descending alphabetical order:\n\nSELECT gummies.name, \n       gummies.description, \n       gummies.colour \nFROM gummies\nORDER BY gummies.name DESC; \n\n\nDisplaying records 1 - 10\n\n\n\n\n\n\n\nname\ndescription\ncolour\n\n\n\n\nVinson Drops\nSoup. Now in gummy form\nbrown\n\n\nTempest\nGet schwasted\ntan\n\n\nSalmoniakki\nSalmon flavored salted licquorice\nblack\n\n\nPain\nMade with Veal; comes with an mp4 of the hand-craftsmanship of orphans making them\nviolet\n\n\nMatchsticks\nGood for eating; not to ignite\nred\n\n\nKitty Litter\nEver wanted to eat the drop box?\nwhite\n\n\nJust Strawberry\nIt’s strawberry, what more do you want to know?!\npink\n\n\ngummyX\nStrangeness\nblue\n\n\nGummy to Go\nMake your friends pee their pants with a gummy laced with diuretics\nyellow\n\n\nGarum Gummae\nA gummy take on a Roman flavor\nblack\n\n\n\n\n\nAnd here we order the gummies in ascending alphabetical order:\n\nSELECT gummies.name, \n       gummies.description, \n       gummies.colour \nFROM gummies\nORDER BY gummies.name ASC; -- Note that ASC is the default and doesn't need to be specified.\n\n\nDisplaying records 1 - 10\n\n\n\n\n\n\n\nname\ndescription\ncolour\n\n\n\n\nApple Bottom Jeans\nGummies shaped like jeans with apple flavor\nblue\n\n\nBada Booms\nAn explosion of taste\nblue\n\n\nDog Residue\nImitates dog dropping with imitation dog dropping flavor\nbrown\n\n\nEye for an Eye\nBlinding flavor\nwhite\n\n\nFroggurt\nFrog meat flavored yogurt gummy\ngreen\n\n\nFrostbite\nImitates how it feels to have frostbite\nblue\n\n\nGarum Gummae\nA gummy take on a Roman flavor\nblack\n\n\nGummy to Go\nMake your friends pee their pants with a gummy laced with diuretics\nyellow\n\n\ngummyX\nStrangeness\nblue\n\n\nJust Strawberry\nIt’s strawberry, what more do you want to know?!\npink"
  },
  {
    "objectID": "sql.html#operators",
    "href": "sql.html#operators",
    "title": "6  Structured Query Language (SQL)",
    "section": "6.6 Operators",
    "text": "6.6 Operators\n\n6.6.1 Arithmetic operators\n\n\n\nOperator\nDescription\n\n\n\n\n+\nAddition\n\n\n-\nSubtraction\n\n\n/\nDivision\n\n\n*\nMultiplication\n\n\n\nThe following statement returns the results of several mathematical operations.\n\nSELECT 1+1, \n       2/4,\n       2*3,\n       8-4\n\n\n1 records\n\n\n?column?\n?column?..2\n?column?..3\n?column?..4\n\n\n\n\n2\n0\n6\n4\n\n\n\n\n\nLet’s try applying an arithmetic operator to a column and retrieve the price per 100 gummies instead of the unitary price.\n\nSELECT \n  gummies.name, \n  gummies.price*100\nFROM gummies\nWHERE price_denominator_id = 2;\n\n\nDisplaying records 1 - 10\n\n\nname\n?column?\n\n\n\n\nVinson Drops\n20\n\n\nSalmoniakki\n50\n\n\nFroggurt\n50\n\n\nGarum Gummae\n100\n\n\nApple Bottom Jeans\n3\n\n\nDog Residue\n1\n\n\nKitty Litter\n1\n\n\nFrostbite\n50\n\n\nMatchsticks\n80\n\n\nGummy to Go\n40\n\n\n\n\n\nWhile the next example wouldn’t make much sense in practice, it shows that you can use arithmetic operators with two columns.\n\nSELECT \n  gummies.name, \n  gummies.price+gummies.price\nFROM gummies;\n\n\nDisplaying records 1 - 10\n\n\nname\n?column?\n\n\n\n\nBada Booms\n0.10\n\n\nVinson Drops\n0.40\n\n\nSalmoniakki\n1.00\n\n\nFroggurt\n1.00\n\n\nGarum Gummae\n2.00\n\n\nApple Bottom Jeans\n0.06\n\n\nDog Residue\n0.02\n\n\nKitty Litter\n0.02\n\n\nFrostbite\n1.00\n\n\nMatchsticks\n1.60\n\n\n\n\n\n\n\n6.6.2 Comparison operators\nThe comparison operators are used to compare values, the result of a comparison is always TRUE (1) or FALSE (0).\n\n\n\n\n\n\n\nOperator\nDescription\n\n\n\n\n=\nEqual\n\n\n>\nGreater than\n\n\n<\nLess than\n\n\n>=\nGreater than or equal to\n\n\n<=\nLess than or equal to\n\n\n<> or !=\nNot equal to\n\n\nIN\nChecks if value is contained in a list of values\n\n\nBETWEEN … AND …\nChecks if value is between two values\n\n\n\nHere is a simple example that shows how the comparison operators work. The returned value for each column is 1 if the statement is true, and 0 if it’s false.\n\nSELECT 'banana' = 'apple'\n\n\n1 records\n\n\n?column?\n\n\n\n\nFALSE\n\n\n\n\n\n\nSELECT 10 < 0\n\n\n1 records\n\n\n?column?\n\n\n\n\nFALSE\n\n\n\n\n\n\nSELECT 'b' BETWEEN 'a' AND 'c'\n\n\n1 records\n\n\n?column?\n\n\n\n\nTRUE\n\n\n\n\n\n\nSELECT  5 >= 5\n\n\n1 records\n\n\n?column?\n\n\n\n\nTRUE\n\n\n\n\n\n\nSELECT 10 < 0\n\n\n1 records\n\n\n?column?\n\n\n\n\nFALSE\n\n\n\n\n\n\nSELECT 8 in (1,4,6,8)\n\n\n1 records\n\n\n?column?\n\n\n\n\nTRUE\n\n\n\n\n\nAs we have already seen when we introduced the WHERE function, the comparison operators are usually used when checking if some condition is met.\nHere is an example in which we retrieve only the Canadian addresses from our address table.\n\nSELECT *\nFROM addresses\nWHERE addresses.country = 'Canada';\n\n\nDisplaying records 1 - 10\n\n\n\n\n\n\n\n\n\n\n\n\nid\naddress1\naddress2\naddress3\ncity\nprovince\ncountry\npostal_code\n\n\n\n\n1\n55\nice cream crescent\nNA\nCandyland\nNS\nCanada\nH2T 1H3\n\n\n2\n66\nvanilla avenue\nNA\nCandyland\nNS\nCanada\nB3L 1A6\n\n\n3\n77\nchocolate avenue\nNA\nCandyland\nNS\nCanada\nB3K 2A7\n\n\n4\n88\nred velvet avenue\nNA\nCandyland\nNS\nCanada\nB3G 4G6\n\n\n5\n99\nmint chocolate chip lane\nNA\nCandyland\nNS\nCanada\nB4R 5F2\n\n\n6\n11\ncandycane street\nNA\nCandyland\nNS\nCanada\nB7R 4H3\n\n\n7\n22\nbrownie court\nNA\nCandyland\nNS\nCanada\nB3J 1D3\n\n\n8\n33\nsour patch drive\nNA\nCandyland\nNS\nCanada\nB3E 0I9\n\n\n9\n44\ncheesecake boulevard\nNA\nCandyland\nNS\nCanada\nB2D 5T6\n\n\n11\n100\nswedish berry cul-de-sac\nNA\nCandyland\nNS\nCanada\nB3D 9G0\n\n\n\n\n\nHere is another example in which we retrieve the name and description of gummies that are hard or stretchy.\n\nSELECT \n  gummies.name, \n  gummies.description\nFROM gummies\nWHERE gummies.consistency IN ('stretchy','hard');\n\n\n8 records\n\n\n\n\n\n\nname\ndescription\n\n\n\n\nSalmoniakki\nSalmon flavored salted licquorice\n\n\nGarum Gummae\nA gummy take on a Roman flavor\n\n\nDog Residue\nImitates dog dropping with imitation dog dropping flavor\n\n\nKitty Litter\nEver wanted to eat the drop box?\n\n\nFrostbite\nImitates how it feels to have frostbite\n\n\nMatchsticks\nGood for eating; not to ignite\n\n\nPain\nMade with Veal; comes with an mp4 of the hand-craftsmanship of orphans making them\n\n\nTempest\nGet schwasted\n\n\n\n\n\n\n\n6.6.3 Logical (boolean) operators\nThe logical operators are used to combine multiple conditions that must all be true for the data to be returned.\n\n\n\n\n\n\n\nOperators\nDescription\n\n\n\n\nAND\nReturns TRUE when all conditions are TRUE. Returns FALSE otherwise\n\n\nOR\nReturns TRUE when at least one of multiple conditions is TRUE. Returns FALSE otherwise\n\n\nNOT\nReturns TRUE when the operand is FALSE, and returns FALSE when the operand is TRUE.\n\n\n\nWe can test the boolean operators with the following statement.\n\nSELECT TRUE, \n       FALSE, \n       NOT FALSE, \n       NOT TRUE, \n       TRUE AND FALSE, \n       TRUE OR FALSE;\n\n\n1 records\n\n\nbool\nbool..2\n?column?\n?column?..4\n?column?..5\n?column?..6\n\n\n\n\nTRUE\nFALSE\nTRUE\nFALSE\nFALSE\nTRUE\n\n\n\n\n\nLet’s now try this in a query and retrieve all gummies from the gummybox_sales database that are blue and AND a semi-hard consistency.\n\nSELECT gummies.id, \n       gummies.name, \n       gummies.description, \n       gummies.consistency, \n       gummies.colour\nFROM gummies \nWHERE gummies.colour = 'blue' AND gummies.consistency = 'hard';\n\n\n1 records\n\n\n\n\n\n\n\n\n\nid\nname\ndescription\nconsistency\ncolour\n\n\n\n\n9\nFrostbite\nImitates how it feels to have frostbite\nhard\nblue\n\n\n\n\n\n\n\n6.6.4 Aggregate functions\n\n\n\nFunction\nDescription\n\n\n\n\nMIN()\nReturns the minimum value of a column.\n\n\nMAX()\nReturns the maximum value of column.\n\n\nSUM()\nReturns the sum of all values in a column.\n\n\nAVG()\nReturns the average value of a column.\n\n\nCOUNT()\nReturns the number of rows.\n\n\n\nLet’s try the aggregate operators by querying the gummybox_sales database to retrieve the number of gummies in the catalogue and their minimum, maximum, and average price.\n\nSELECT \n  COUNT(*), \n  MIN(gummies.price), \n  MAX(gummies.price), \n  AVG(gummies.price)\nFROM gummies;\n\n\n1 records\n\n\ncount\nmin\nmax\navg\n\n\n\n\n16\n0.01\n1\n0.434375\n\n\n\n\n\nWe can see that there are 15 entries in the gummies table, with prices ranging from 0.01$ to 1.00$ and an average price of 0.45$.\nOften times, you will want to retrieve these aggregate values for different subsets of records (e.g. to perform group comparisons). This is where the GROUP BY function comes into play. In fact, you must include a GROUP BY in your statement whenever you use an aggregate operator, unless all of your returned values are aggregates (as in the example above). Let’s write a query that returns the number of records, and the minimum, maximum, and average price for gummies of different consistency.\n\nSELECT \n  gummies.consistency, \n  COUNT(*), \n  MIN(gummies.price), \n  MAX(gummies.price), \n  AVG(gummies.price)  \nFROM gummies\nGROUP BY gummies.consistency;\n\n\n4 records\n\n\nconsistency\ncount\nmin\nmax\navg\n\n\n\n\nhard\n7\n0.01\n0.8\n0.4600000\n\n\nsoft\n6\n0.05\n0.9\n0.4166667\n\n\nstretchy\n1\n1.00\n1.0\n1.0000000\n\n\nchewy\n2\n0.03\n0.2\n0.1150000\n\n\n\n\n\nIt’s important to know that PostgreSQL will not return an error message if you forget the GROUP BY part of your statement. But will instead provide an erroneous result: the first value for gummy.consistency and the aggregate value for all of the records in the table. So remember to always examine the results of your queries (no matter what they are) to see if they are consistent with your expectations, and to not simply trust that all is fine and that the query worked and did what you wanted it to do because there is no error or warning message."
  },
  {
    "objectID": "sql.html#combining-joining-tables",
    "href": "sql.html#combining-joining-tables",
    "title": "6  Structured Query Language (SQL)",
    "section": "6.7 Combining (joining) tables",
    "text": "6.7 Combining (joining) tables\n\n6.7.1 JOIN (INNER JOIN)\nThe JOIN returns only records for which the matching condition is TRUE. Here is an example, where I bring together the order and the gummy_order to see what gummies are part of each order, and in what quantity.\n\nSELECT *\nFROM orders\nJOIN gummies_orders ON gummies_orders.order_id = orders.id;\n\n\nDisplaying records 1 - 10\n\n\nid\ncustomer_id\naddress_id\ndate\ngummy_id\norder_id\nquantity\n\n\n\n\n1\n2\n3\n1995-08-08\n1\n1\n5\n\n\n2\n3\n4\n1996-05-30\n2\n2\n2\n\n\n3\n4\n5\n1994-11-05\n3\n3\n7\n\n\n4\n5\n6\n1998-09-02\n4\n4\n25\n\n\n5\n6\n7\n1993-10-15\n5\n5\n90\n\n\n7\n8\n9\n2002-01-15\n7\n7\n17\n\n\n8\n9\n10\n1987-09-12\n8\n8\n34\n\n\n9\n10\n1\n1999-06-30\n9\n9\n76\n\n\n1\n2\n3\n1995-08-08\n10\n1\n12\n\n\n2\n3\n4\n1996-05-30\n11\n2\n96\n\n\n\n\n\n\n\n6.7.2 LEFT JOIN\nThe LEFT JOIN function returns all records from the original table and only records from the joined table for which the matching condition is TRUE. This can be useful if I want to retrieve, for example, a list of all the gummies and the orders in which they were included, but keep in my list the gummies that were part of 0 orders.\n\nSELECT \n  gummies.name,\n  gummies_orders.order_id\nFROM gummies\nLEFT JOIN gummies_orders ON gummies_orders.gummy_id = gummies.id;\n\n\nDisplaying records 1 - 10\n\n\nname\norder_id\n\n\n\n\nBada Booms\n1\n\n\nVinson Drops\n2\n\n\nSalmoniakki\n3\n\n\nFroggurt\n4\n\n\nGarum Gummae\n5\n\n\nDog Residue\n7\n\n\nKitty Litter\n8\n\n\nFrostbite\n9\n\n\nMatchsticks\n1\n\n\nGummy to Go\n2\n\n\n\n\n\n\n\n6.7.3 RIGHT JOIN\nThe RIGHT JOIN function is the same as the LEFT JOIN function returns all records from the joined table and only records from the original table for which the matching condition is TRUE.\nNote: You rarely use right join in practice. It is usually a better idea to use a LEFT JOIN, since most RIGHT JOIN statements can be reformulated as LEFT JOIN statements.\n\nSELECT gummies_orders.order_id,\n       gummies.name\nFROM gummies_orders\nRIGHT JOIN gummies ON gummies.id = gummies_orders.gummy_id;\n\n\n\n6.7.4 UNION\nWhile the JOIN functions are used to combine fields from different tables horizontally, the UNION function vertically combines two tables. Note that this requires that the two combined tables have the same structure (same fields). In our database. Let’s use the UNION function to make a list of the names and descriptions of all the products (gummies and boxes) in our inventory.\n\nSELECT gummies.name,\n       gummies.description\nFROM gummies\nUNION\nSELECT boxes.name,\n       boxes.description\nFROM boxes;\n\n\nDisplaying records 1 - 10\n\n\nname\ndescription\n\n\n\n\nMatchsticks\nGood for eating; not to ignite\n\n\nSalty Boiz\nA collection of salty treats to dry your tongue\n\n\nSalmoniakki\nSalmon flavored salted licquorice\n\n\nVinson Drops\nSoup. Now in gummy form\n\n\nMouth Tingles\nAn explosion of flavours\n\n\nEarthy Fusion\nFruity and tootie and earthy delights\n\n\ngummyX\nStrangeness\n\n\nApple Bottom Jeans\nGummies shaped like jeans with apple flavor\n\n\nFrostbite\nImitates how it feels to have frostbite\n\n\nFroggurt\nFrog meat flavored yogurt gummy\n\n\n\n\n\nAs you might have noticed from the previous example, the “peak-a-chew” and “crocodile gumdee” gummies are available in both stores. The UNION function automatically removes duplicates and returns only distinct records. If you would like to keep the duplicate rows, this can be achieved with the UNION ALL function."
  },
  {
    "objectID": "sql.html#aliases-as",
    "href": "sql.html#aliases-as",
    "title": "6  Structured Query Language (SQL)",
    "section": "6.8 Aliases (AS)",
    "text": "6.8 Aliases (AS)\nAliases are used to rename things within your SQL statements. You can change the name of a field or table. You can even change the data type of a field. Unless used in a CREATE or ALTER statement the Aliases do not modify your database. They are simply used for the specific statement that you are executing. We will focus here on one function of aliases: setting column names for the output of your SQL queries.\n\n6.8.0.1 Setting column names\nA typical use of aliases is to choose a column name that is more appropriate for a display that is intended for the user. This is especially useful when you use arithmetic or aggregate operators, for instance. Here’s an example where we get the list of gummies and the price included in the order that has id 1.\n\nSELECT gummies_orders.order_id, \n  gummies.name AS Name,\n  gummies_orders.quantity AS Quantity,\n  gummies_orders.quantity * gummies.price AS Price\nFROM gummies_orders \nJOIN gummies ON gummies.id = gummies_orders.gummy_id\nWHERE gummies_orders.order_id = 1;\n\n\n2 records\n\n\norder_id\nname\nquantity\nprice\n\n\n\n\n1\nBada Booms\n5\n0.25\n\n\n1\nMatchsticks\n12\n9.60\n\n\n\n\n\n\n\n6.8.0.2 Setting table names\nGiving an alias to tables in your query can make them easier to write (and read).\n\nSELECT go.order_id, \n  g.name AS Name,\n  go.quantity AS Quantity,\n  go.quantity * g.price AS Price\nFROM gummies_orders AS go \nJOIN gummies as g ON g.id = go.gummy_id\nWHERE go.order_id = 1;\n\n\n2 records\n\n\norder_id\nname\nquantity\nprice\n\n\n\n\n1\nBada Booms\n5\n0.25\n\n\n1\nMatchsticks\n12\n9.60"
  },
  {
    "objectID": "sql.html#database-views",
    "href": "sql.html#database-views",
    "title": "6  Structured Query Language (SQL)",
    "section": "6.9 Database views",
    "text": "6.9 Database views\nWhat are views? technically they are not much more than stored query (in some DBMS, they views are actually called “stored queries”) with an alias.\nIn practice, and for the purpose of this course, we will think of views as tables that your users may wish or need to see (or “view”) to obtain information or perform a certain task.\n\n6.9.0.1 Single table view\nCreating views in PostgreSQL is pretty simple, here is an example of a single table view that simply provides the list of customers and their email address.\n\n\n\n\nCREATE VIEW customers_emails AS\nSELECT DISTINCT first_name, last_name, email FROM customers;\n\nSo now we can view the list of emails by retrieving records from our view.\n\nSELECT * FROM customers_emails;\n\n\nDisplaying records 1 - 10\n\n\n\n\n\n\n\nfirst_name\nlast_name\nemail\n\n\n\n\nBasil\nExposition\nhappygolucky@britishintelligence.uk\n\n\nNumber\n2\ntwentytwentyvision@evil.org\n\n\nAustin\nPowers\ngroovybaby@ministryofdefence.uk\n\n\nMr.\nBigglesworth\ndestroyerofworlds@evil.org\n\n\nMini\nMe\nilovechocolate@evil.org\n\n\nDr.\nEvil\ndouglaspowers@evil.org\n\n\nNigel\nPowers\neasypeasylemonsqueezy@britishintelligence.uk\n\n\nScott\nEvil\ndaddywasntthere@evil.org\n\n\nGold\nMember\n24k@rollerdisco.com\n\n\nFoxxy\nCleopatra\nsugar@wholelottawoman.com\n\n\n\n\n\n\n\n6.9.0.2 Multitable view\nYou can also create views that combine data from multiple tables using the JOIN or UNION function. Here is an example where we\n\n\n\n\nCREATE VIEW delivery_addresses AS\nSELECT DISTINCT \n  orders.id, \n  customers.first_name, \n  customers.last_name, \n  addresses.address1, \n  addresses.address2, \n  addresses.address3, \n  addresses.city, \n  addresses.province, \n  addresses.country, \n  addresses.postal_code\nFROM orders\nJOIN customers ON customers.id = orders.customer_id\nJOIN addresses ON addresses.id = orders.address_id;\n\nThen I can simply request the delivery_addresses for all orders like this:\n\nSELECT * \nFROM delivery_addresses;\n\n\nDisplaying records 1 - 10\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nid\nfirst_name\nlast_name\naddress1\naddress2\naddress3\ncity\nprovince\ncountry\npostal_code\n\n\n\n\n5\nNumber\n2\n22\nbrownie court\nNA\nCandyland\nNS\nCanada\nB3J 1D3\n\n\n2\nFoxxy\nCleopatra\n88\nred velvet avenue\nNA\nCandyland\nNS\nCanada\nB3G 4G6\n\n\n7\nGold\nMember\n44\ncheesecake boulevard\nNA\nCandyland\nNS\nCanada\nB2D 5T6\n\n\n8\nMr.\nBigglesworth\n55\nsnowcone crossing\nNA\nCandyland\nNS\nCanada\nB4F 5T0\n\n\n1\nBasil\nExposition\n77\nchocolate avenue\nNA\nCandyland\nNS\nCanada\nB3K 2A7\n\n\n6\nScott\nEvil\n33\nsour patch drive\nNA\nCandyland\nNS\nCanada\nB3E 0I9\n\n\n10\nAustin\nPowers\n66\nvanilla avenue\nNA\nCandyland\nNS\nCanada\nB3L 1A6\n\n\n3\nDr.\nEvil\n99\nmint chocolate chip lane\nNA\nCandyland\nNS\nCanada\nB4R 5F2\n\n\n4\nMini\nMe\n11\ncandycane street\nNA\nCandyland\nNS\nCanada\nB7R 4H3\n\n\n9\nNigel\nPowers\n55\nice cream crescent\nNA\nCandyland\nNS\nCanada\nH2T 1H3"
  },
  {
    "objectID": "sql.html#putting-it-all-together",
    "href": "sql.html#putting-it-all-together",
    "title": "6  Structured Query Language (SQL)",
    "section": "6.10 Putting it all together",
    "text": "6.10 Putting it all together\nLet us now combine several of the functions that we learned to create a view that provides the average price of hard gummies. We will build the statement one piece at a time.\n\n6.10.0.1 Step 1 - starting with the gummy table\n\nSELECT *\nFROM gummies\n\n\nDisplaying records 1 - 10\n\n\n\n\n\n\n\n\n\n\n\n\n\nid\nname\ndescription\nconsistency\ncolour\nflavour\nflavour_type_id\nprice\nprice_denominator_id\n\n\n\n\n1\nBada Booms\nAn explosion of taste\nsoft\nblue\nstrawberry\n1\n0.05\n1\n\n\n2\nVinson Drops\nSoup. Now in gummy form\nchewy\nbrown\nsoup\n2\n0.20\n2\n\n\n3\nSalmoniakki\nSalmon flavored salted licquorice\nhard\nblack\nsalmon liquorice\n2\n0.50\n2\n\n\n4\nFroggurt\nFrog meat flavored yogurt gummy\nsoft\ngreen\nfrog\n1\n0.50\n2\n\n\n5\nGarum Gummae\nA gummy take on a Roman flavor\nstretchy\nblack\nanchovie\n3\n1.00\n2\n\n\n6\nApple Bottom Jeans\nGummies shaped like jeans with apple flavor\nchewy\nblue\napple\n1\n0.03\n2\n\n\n7\nDog Residue\nImitates dog dropping with imitation dog dropping flavor\nhard\nbrown\ndog\n4\n0.01\n2\n\n\n8\nKitty Litter\nEver wanted to eat the drop box?\nhard\nwhite\nammonia\n4\n0.01\n2\n\n\n9\nFrostbite\nImitates how it feels to have frostbite\nhard\nblue\nminty\n5\n0.50\n2\n\n\n10\nMatchsticks\nGood for eating; not to ignite\nhard\nred\nphosphorus\n3\n0.80\n2\n\n\n\n\n\n\n\n6.10.0.2 Step 2 - getting the flavour_type for each gummy\n\nSELECT \n  gummies.id, \n  gummies.name, \n  gummies.consistency, \n  flavour_types.flavour_type, \n  gummies.price\nFROM gummies\nLEFT JOIN flavour_types ON flavour_types.id = gummies.flavour_type_id\n\n\nDisplaying records 1 - 10\n\n\nid\nname\nconsistency\nflavour_type\nprice\n\n\n\n\n16\ngummyX\nsoft\nsweet\n0.25\n\n\n15\nJust Strawberry\nsoft\nsweet\n0.40\n\n\n14\nEye for an Eye\nsoft\nsweet\n0.90\n\n\n6\nApple Bottom Jeans\nchewy\nsweet\n0.03\n\n\n4\nFroggurt\nsoft\nsweet\n0.50\n\n\n1\nBada Booms\nsoft\nsweet\n0.05\n\n\n12\nPain\nhard\numami\n0.60\n\n\n3\nSalmoniakki\nhard\numami\n0.50\n\n\n2\nVinson Drops\nchewy\numami\n0.20\n\n\n10\nMatchsticks\nhard\nsalty\n0.80\n\n\n\n\n\n\n\n6.10.0.3 Step 3 - Limiting to hard gummies\n\nSELECT \n  gummies.id, \n  gummies.name, \n  gummies.consistency, \n  flavour_types.flavour_type, \n  gummies.price \nFROM gummies\nLEFT JOIN flavour_types ON flavour_types.id = gummies.flavour_type_id\nWHERE gummies.consistency = 'hard';\n\n\n7 records\n\n\nid\nname\nconsistency\nflavour_type\nprice\n\n\n\n\n3\nSalmoniakki\nhard\numami\n0.50\n\n\n7\nDog Residue\nhard\nbitter\n0.01\n\n\n8\nKitty Litter\nhard\nbitter\n0.01\n\n\n9\nFrostbite\nhard\nlidocaine\n0.50\n\n\n10\nMatchsticks\nhard\nsalty\n0.80\n\n\n12\nPain\nhard\numami\n0.60\n\n\n13\nTempest\nhard\nsour\n0.80\n\n\n\n\n\n\n\n6.10.0.4 Step 4 - Selecting final columns to display and calculating values\n\nSELECT \n  gummies.consistency AS Consistency, \n  flavour_types.flavour_type AS \"Flavour type\", \n  COUNT(*) AS \"Number of gummies\",\n  AVG(gummies.price) AS \"Average price\"\nFROM gummies\nLEFT JOIN flavour_types \n  ON flavour_types.id = gummies.flavour_type_id\nWHERE gummies.consistency = 'hard'\nGROUP BY gummies.consistency, flavour_types.flavour_type;\n\n\n5 records\n\n\nconsistency\nFlavour type\nNumber of gummies\nAverage price\n\n\n\n\nhard\nbitter\n2\n0.01\n\n\nhard\nlidocaine\n1\n0.50\n\n\nhard\nsalty\n1\n0.80\n\n\nhard\nsour\n1\n0.80\n\n\nhard\numami\n2\n0.55\n\n\n\n\n\n\n\n6.10.0.5 Step 5 - Storing this virtual table as a view\n\nDROP VIEW IF EXISTS gummies_stats;\n\n\nCREATE VIEW gummies_stats AS\nSELECT \n  gummies.consistency AS Consistency, \n  flavour_types.flavour_type AS \"Flavour type\", \n  COUNT(*) AS \"Number of gummies\",\n  AVG(gummies.price) AS \"Average price\"\nFROM gummies\nLEFT JOIN flavour_types ON flavour_types.id = gummies.flavour_type_id\nWHERE gummies.consistency = 'hard'\nGROUP BY gummies.consistency, flavour_types.flavour_type;\n\n\n\n6.10.0.6 Step 6 - using the view\n\nSELECT * FROM gummies_stats;\n\n\n5 records\n\n\nconsistency\nFlavour type\nNumber of gummies\nAverage price\n\n\n\n\nhard\nbitter\n2\n0.01\n\n\nhard\nlidocaine\n1\n0.50\n\n\nhard\nsalty\n1\n0.80\n\n\nhard\nsour\n1\n0.80\n\n\nhard\numami\n2\n0.55"
  },
  {
    "objectID": "sql.html#homework",
    "href": "sql.html#homework",
    "title": "6  Structured Query Language (SQL)",
    "section": "6.11 Homework",
    "text": "6.11 Homework\nYou are now ready to do individual lab #3 AND the (final) part #3 of your team assignment. Have fun!"
  }
]