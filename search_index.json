[["document-oriented-databases.html", "Document-oriented databases Learning objectives NoSQL databases Document-oriented databases Exercises My solution Additional resources", " Document-oriented databases Learning objectives Concepts NoSQL databases Document-oriented databases (or document stores) Practical skills Writing a JSON document. NoSQL databases Now that you have become familiar with relational databases, we will be turning our attention to different types of databases: the document-oriented database (also called document stores), and the graph databases (well cover those in the next chapter). These are two variants of a much wider range of database types that, together, are regrouped under the NoSQL label (which can refer to non-SQL or not only SQL). These databases have grown in popularity with the rise of the web 2.0 and cloud computing, as well as the diminishing costs of data storage. Unlike relational databases that share a common language (SQL), there is no standard in the NoSQL world. However, we will not be discussing these languages in this course, but instead focus on how the document-oriented databases and graph databases differ from relational databases in the way that they organize data. Document-oriented databases There exists a wide variety of document-oriented databases, each with their own particularities. We will focus here on one very popular example of document-oriented databases: MongoDB (https://www.mongodb.com/). Lets look at the main differences between MongoDB and MySQL. Documents and collections Instead of using storing records in tables as in the relational model, MongoDB (and other document-oriented databases) do not split the data into multiple tables that are linked together through foreign keys. Instead, data is stored in documents that are grouped together in collections. While they are not conceptually equivalent, documents are to document-oriented databases what tables are to relational databases: they are individual records that have a unique identifier. collections are group of documents, just like tables are groups of records. Non-structured data Rather than the structured data format of relational databases, document-oriented databases use non-structure data formats like XML and JSON. MongoDB uses the JSON format. As you might recall from the first chapter of this course, one particularity of the non-structured data formats is that the structure of the data is included directly in each document, which means that each document in a collection can have a different structure. No (very few) relations Another important feature of the JSON format is that it can include a list of values in a single field. This eliminates the need for associative tables, and consequently, the need to retrieve data with more or less complex SQL queries pulling data from multiple tables using JOINs. With document-oriented databases, the documents contain all the data that we need, reducing the need to pull data from other collections. That said, it remains possible to link collections together, but this is not a typical use of document-oriented databases. Implications for database design The differences between the relational and the document-oriented databases presented so far may seem a bit superficial or technical, but they also have important implications when it comes to designing databases. Most importantly, the documents include not only the entities attribute but also their relationship with other entities. This means 1) that the same data can be repeated in multiple documents and collections, and 2) that there is no need for associative or validation tables. The following video explains in more details these fundamental differences between the two types of databases. MongoDB demo In this video, I demonstrate how to create a collection and documents in MongoDB (errata: at time 8:10, I include an object called orders. What I actually should have done is create an array, and then make each entry in that array an object): Exercises The GummyBox CEO asked you to create a collection of customers documents in MongoDB. Each document should include information about the customers (name, contact information, address(es), as well as the orders and the reviews that they made. To get started you used the MySQL server to retrieve the data to be included in the customers documents . The tables are below, and you now want to create a single JSON file that will combine all this information. (Note that even though the customer as a single address in the database, you want to design your documents so that a secondary address for the customer could easily be added). Customer information customer_id first_name last_name email phone_number membership_type 1 Mickey Mouse mickey.mouse@disney.com silver Addresses address city state country postal_code main_address 172 Disney road Los Angeles CA USA 12345 1 Orders summary order_id date total 1001 2020-01-02 16.25 1002 2020-06-30 0.25 Orders details order_id gummy_name quantity gummy_price subtotal 1001 Bada Booms 25 0.15 3.75 1001 Cherry blasters 50 0.20 10.00 1001 Jaw Breakers 10 0.25 2.50 1002 Jaw Breakers 1 0.25 0.25 Reviews gummy_id gummy_name review_date rating review 1 Bada Booms 2020-03-15 5 These are just the best I eat a whole bag every day! 2 Cherry Coke 2020-09-25 3 I disagree with the previous review. These gummies may not be my favorite, but I enjoy them from time to time My solution This is my solution in JSON format. Yours may be different:. { # Start of document &quot;customer_id&quot;: 1, &quot;first_name&quot;: &quot;Mickey&quot;, &quot;last_name&quot;: &quot;Mouse&quot;, &quot;email&quot;: &quot;mickey.mouse@disney.com&quot;, &quot;phone_number&quot;: &quot;&quot;, &quot;membership_type&quot;: &quot;Silver&quot;, &quot;addresses&quot;: [ # This square bracket indicates the beginning of an array { # This brackets starts the first object of the addresses array &quot;street_address&quot;: &quot;172 Disney Road&quot;, &quot;city&quot;: &quot;Los Angeles&quot;, &quot;state&quot;: &quot;CA&quot;, &quot;postal_code&quot;: 12345, &quot;main_address&quot;: true } # End of first object in the addresses array ], # End of the addresses arrat &quot;orders&quot;: [ # Start of the orders array { # First object in the orders array begins &quot;order_id&quot;: 1001, &quot;date&quot;: &quot;2020-01-02&quot;, &quot;total&quot;: 16.25, &quot;order_details&quot;: [ # Start of an order_details array within the first order object { # First object of the order_details &quot;gummy_name&quot;: &quot;Bada booms&quot;, &quot;quantity&quot;: 25, &quot;gummy_price&quot;: 0.15, &quot;subtotal&quot;: 3.75 }, # End of first object { # Start of second object &quot;gummy_name&quot;: &quot;Cherry Blasters&quot;, &quot;quantity&quot;: &quot;50&quot;, &quot;gummy_price&quot;: 0.20, &quot;subtotal&quot;: 10.00 }, # End of second object { # Start of third object &quot;gummy_name&quot;: &quot;Jaw Breakers&quot;, &quot;quantity&quot;: 10, &quot;gummy_price&quot;: 0.25, &quot;subtotal&quot;: 2.50 } # End of third object ] # End of order_details array }, # End of first order object { # Start of second order object &quot;order_id&quot;: 1002, &quot;date&quot;: &quot;2020-06-30&quot;, &quot;total&quot;: 0.25, &quot;order_details&quot;: [ # Start of order_details array { # Start of first object &quot;gummy_name&quot;: &quot;Jaw Breakers&quot;, &quot;quantity&quot;: 1, &quot;gummy_price&quot;: 0.25, &quot;subtotal&quot;: 0.25 } # End of first object ] # End of of order_details array } # End of second order object ], # End of the orders array &quot;reviews&quot;: [ # Start of the reviews array { # Start of first review object &quot;gummy_id&quot;: 1, &quot;gummy_name&quot;: &quot;Bada Booms&quot;, &quot;review_date&quot;: &quot;2020-03-15&quot;, &quot;rating&quot;: 5, &quot;review&quot;: &quot;These are just the best I eat a whole bag every day!&quot; }, # End of first review object { # Start of second review object &quot;gummy_id&quot;: 2, &quot;gummy_name&quot;: &quot;Cherry Coke&quot;, &quot;review_date&quot;: &quot;2020-09-25&quot;, &quot;rating&quot;: 3, &quot;review&quot;: &quot;I disagree with the previous review. These gummies may not be my favorite, but I enjoy them from time to time&quot; } # End of second review object ] # End of the reviews array } # End of the document Additional resources You can use this online JSON validator and formatter to help you write JSON and convert your data from JSON to CSV or XML or vice versa. You can install a local MongoDB server on your computer if you want to use it to create your own document collections. MongoDB offers a series of free online courses that can also help get you started. "]]
